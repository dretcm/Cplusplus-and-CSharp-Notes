------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------" C ++ "--------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
# best onlie ide:
https://onecompiler.com 

# RUN a script .cpp by console:
# remenber that g++ must local varible system "C:\Program Files (x86)\Dev-Cpp\MinGW64\bin\g++"
# or with https://sourceforge.net/projects/mingw-w64/
D:\...>g++ test.cpp -o go_test.exe      # this create a file "go_test.exe"
D:\...>go.exe

# RUN in NotePad++ with path:
NPP_SAVE
CD "$(CURRENT_DIRECTORY)"
"C:\Program Files (x86)\Dev-Cpp\MinGW64\bin\g++" "$(FILE_NAME)" -o "$(NAME_PART).exe"
"$(NAME_PART).exe"


# RUN in NotePad++ with system variable:
NPP_SAVE
CD "$(CURRENT_DIRECTORY)"
g++ "$(FILE_NAME)" -o "$(NAME_PART).exe"
"$(NAME_PART).exe"

# $(CURRENT_DIRECTORY) is equals to "D:\...\"
# $(FILE_NAME) is equals to "test.cpp"
# $(FILE_PART) is equals to "test"

-------------------

1.//para usar el len en c++ se usa el comando "strlen(palabra_a_contar)";

#include<conio.h>  y getch() ---al final del programa antes del return 0;;
para q peude ejecutarce.

#include<stdlib.h> y system("pause"); ----al final, tambien puede pausarce el programa 
al ejecutarce, es parecido al #include<conio.h> y getch();

------------------>>> Init variables : int input with char : cin :

#include <iostream>
using namespace std;

int main()
{
	int a, b=2, c(3);
	a = 1;
	// c(4); // Error

	cout << "a":<<a<<endl;
	cout << "b":<<b<<endl;
	cout << "c":<<c<<endl;

	return 0;
}

OUTPUT:
a: 1
b: 2
c: 3

// cin wiht error:

#include <iostream>
using namespace std;

int main()
{
	int a;
	cout << "enter a character:; cin >> a;
	cout << "a: " << a << endl;   // if we put a character in a int input the compiler will take it as None or 0.

	return 0;
}

OUTPUT:
enter a character: u
a: 0


------------------->>> special tokens : use beep :

Escape        sequence Description

\n 	Newline. Position the screen cursor to the beginning of the next line.
\t 	Horizontal tab. Move the screen cursor to the next tab stop.
\r 	Carriage return. Position the screen cursor to the beginning of the current line; do not advance to the next line.
\a 	Alert. Sound the system bell.
\\ 	Backslash. Used to print a backslash character.
\' 	Single quote. Used to print a single-quote character.
\" 	Double quote. Used to print a double-quote character



// Beep windows.h :

#include <iostream> 
#include <windows.h> // WinApi header 

using namespace std;

int main() 
{ 
    Beep(523,500); // 523 hertz (C5) for 500 milliseconds     
    cin.get(); // wait 
    return 0; 
}


// Notes of music :

DO RE MI FA SOL LA SI
C  D  E  F  G   A  B

#include <iostream> 
#include <windows.h>
using namespace std;

#define time 200
#define Do Beep(261,time)
#define Re Beep(293,time)
#define Mi Beep(329,time)
#define Fa Beep(349,time)
#define Sol Beep(392,time)
#define La Beep(440,time)
#define Si Beep(493,time)
					  
int main() 
{ 
    //Beep(1000,1000);
	Do;Do;Do;Fa;La;
	Do;Do;Do;Fa;La;
	
	Fa;Fa;Mi;Mi;Re;Re;Do;

	Do;Do;Do;Mi;Sol;
	Do;Do;Do;Mi;Sol;
	
	Sol;La;Sol;Fa;Mi;Re;Do;
	
    cin.get(); // wait 
    return 0; 
}

--------------------- types of clear screen :

// form 1
system("cls");
// system("clear screen"); optional

// CODE ANSI : https://en.wikipedia.org/wiki/ANSI_escape_code
// form 2
std::cout << "\033[H\033[2J\033[3J";

// form 3
#include <windows.h>
void clear_screen() {
    COORD topLeft  = { 0, 0 };
    HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO screen;
    DWORD written;

    GetConsoleScreenBufferInfo(console, &screen);
    FillConsoleOutputCharacterA(
        console, ' ', screen.dwSize.X * screen.dwSize.Y, topLeft, &written
    );
    FillConsoleOutputAttribute(
        console, FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE,
        screen.dwSize.X * screen.dwSize.Y, topLeft, &written
    );
    SetConsoleCursorPosition(console, topLeft);
}


--------------------------- char null : use null : pointer and reference : use pointers

char a = '\0'; // these is equivalent to NULL value.
int b = NULL; // null, but with other types of data char.
string c = NULL;


//null pointer :

int *ptr = nullptr;

// pointer and reference :
#include <iostream>

int main (){
        char ptrStr1[15] = "Hola Mundo";
	char *ptrStr = *&ptrStr1;
	std::cout << &ptrStr1<<std::endl;  // 0x61fead
        std::cout << *ptrStr1<<std::endl; // H
	std::cout << *&ptrStr1<<std::endl; // Hola Mundo
	
	ptrStr[0] = 'A';
	std::cout << ptrStr1<<std::endl; // Aola Mundo
		
	return 0;
}


// pointer modificate by the  "*" :
#include <iostream>

int main (){
        int *ptr, num = 3;
	ptr = &num;
	*ptr = 5;

	std::cout << num <<std::endl;  // 5
        std::cout << *ptr <<std::endl; // 5
	num = 6;
	std::cout << num <<std::endl;  // 6
        std::cout << *ptr <<std::endl; // 6
		
	return 0;
}


// with arrays :
#include <iostream>

int main (){
    	int *ptr, arr[5] = {1,2,3,4,5};
	ptr = &(arr[0]);

	std::cout << *ptr <<std::endl;  // 1
	ptr++;
    	std::cout << *ptr <<std::endl; // 2
	ptr+=2;
	std::cout << *ptr <<std::endl;  // 4
		
	return 0;
}


// functions with arrays : funtion array pointer :

#include <iostream>
using namespace std;

void show(int *arr){
	// first for:
	std::cout<<*arr<<std::endl;
	arr++;
	std::cout<<*arr<<std::endl;
	arr++;
	std::cout<<*arr<<std::endl;
	arr++;
	std::cout<<*arr<<std::endl;
	
	arr-=3; // return to the first element by means of memmory
	
	// second for:
	for(int i=0; i<4; i++){
		std::cout<<arr[i]<<std::endl;
	}
	
	arr[0] = 123;  // changue the value by the memmory.
}

int main() {
	int arr[]={3,2,1,5};
	show(arr);
	std::cout<<"change after function: "<<arr[0]<<std::endl;
	return 0;
}

//OUTPUT:
3
2
1
5
3
2
1
5
change after function: 123


// *& in functions:
#include <iostream>
using namespace std;

void run_run(int *&ptr){
  ptr = new int;
  *ptr = 5;
  cout<<"value func: "<<*ptr<<endl;
}

int main() {
  int *p = nullptr;
  run_run(p);
  cout<<"value: "<<*p<<endl;
  
  //delete p;
  return 0;
} 

OUTPUT:
value func: 5
value: 5

--------------------- use namespace :

//////// main.cpp /////////
#include <iostream>
#include "my_package"

int main(){
	std::cout << "hi"<< std:endl;
	mp::show();
	return 0;
}

/////// my_package.cpp ///////
#include <iostream>
namespace mp
{
	void show(){
		std::cout<<"my cout package"<<std::endl;
	}
}

------------------------------------------------ use time.h : use random :

--->> #include<time.h>
//y este tipo de metodo es requerible q se use el #include<stdlib.h>
//porque el conio.h no corre. 
srand(time(NULL));
valor=(1+rand()%(100)); 
//esto dara numeros aleatorios o algo aprecido a eso.

v1 = rand() % 100;         // v1 in the range 0 to 99
v2 = rand() % 100 + 1;     // v2 in the range 1 to 100
v3 = rand() % 30 + 1985;   // v3 in the range 1985-2014 


// Measure execution time of a function in C++

#include <algorithm>
#include <chrono>
#include <iostream>
#include<vector>
using namespace std;
using namespace std::chrono;

int main()
{
  
    vector<int> values(10000);
  
    // Generate Random values
    auto f = []() -> int { return rand() % 10000; };
  
    // Fill up the vector
    generate(values.begin(), values.end(), f);
  
    // Get starting timepoint
    auto start = high_resolution_clock::now();
  
    // Call the function, here sort()
    sort(values.begin(), values.end());
  
    // Get ending timepoint
    auto stop = high_resolution_clock::now();
  
    // Get duration. Substart timepoints to 
    // get durarion. To cast it to proper unit
    // use duration cast method
    auto duration = duration_cast<microseconds>(stop - start);
  
    cout << "Time taken by function: "
         << duration.count() << " microseconds" << endl;
  
    return 0;
}



// use time(NULL); :

return a int of the clock in your pc:
example:
12312351
... // later 1 sec
12312352
... // later 1 sec
12312353
... etc sec

// use clock();

return to pulses of the clock in your pc
2
3
4
5
6
7
...
123
124
...
743

------------------------------------------------

//los arrays en c++ serian haci :

int numbers[10];
char frases[15];
float reals[20];
double greats[17];
//son para introducir.
//los q ya son definidos serian haci.
int numbers[]={1,3,5,7,9};
// numbers[0]=1;
// numbers[1]=3;
// numbers[2]=5;
char lettlers[]={'a','b','c'};
// lettlers[0]='a';
// lettlers[1]='b';

// other form :

int [] {1,2,3,45,5};

// is equals to:

int [5] {1,2,45,5};

--VARIABLE STRING O CADENA :

#include<iostream>
#include<conio.h>
using namespace std;

int main(){
	string vec[]={"alex","perro","gaa"};

	for(int i=0;i<3; i++){
		cout<<"-> "<<vec[i]<<endl;
	}
	
	getch();
	return 0;
}

----------------->>> use printf :  use sizeof : use scanf : ascii cout : linux ascii : lenghr array :

int a=1;
float b=3.2;
char c = 'a';
bool d = true;
double e=123.2131231231231123131231312312323;
long double f=213.23131231232323213...1231231332312313;
string g = "hello";

printf("%i", a) // or printf("%d", a)
printf("%f", b)
printf("%c", c)  // aslo we use code ascii // printf("%c", 254)
printf("%d", d)
printf("%f", e)
printf("%lf", f)
printf("%s", g)



// size of:
// data types : https://ccia.ugr.es/~jfv/ed1/c/cdrom/cap2/cap24.htm

#include <iostream>

int main(){
	int a=1;
	char b = 'a';
	float c=3.2;
	bool d = true;
	double e=123.2131231231231123131231312312323;
	long double f=213123213.25353531312312323232131231231332312313;
	long int g =  133113131;
	std::string h = "hello";
	
	std::cout <<"int bytes: "<<sizeof(a)<<std::endl;
	std::cout <<"char bytes: "<<sizeof(b)<<std::endl;
	std::cout <<"float bytes: "<<sizeof(c)<<std::endl;
	std::cout <<"bool bytes: "<<sizeof(d)<<std::endl;
	std::cout <<"double bytes: "<<sizeof(e)<<std::endl;
	std::cout <<"long double bytes: "<<sizeof(f)<<std::endl;
	std::cout <<"long int bytes: "<<sizeof(g)<<std::endl;
	std::cout <<"string bytes: "<<sizeof(h)<<std::endl;

	return 0;
}
OUTPUT:
int bytes: 4
char bytes: 1
float bytes: 4
bool bytes: 1
double bytes: 8
long double bytes: 12
long int bytes: 4
string bytes: 24


// get lenght of array :

#include <iostream>
int main(){
	int arr[3] = {1,2,3};
	std::cout<<"lenght of int arr: "<<sizeof(arr) / sizeof(arr[0])<<std::endl;

	return 0;
}
//Output:
lenght of int arr: 3


// scanf :

#include <stdio.h>

int main ()
{
  char str [80];
  int i;

  printf ("Enter your family name: ");
  scanf ("%79s",str);  
  printf ("Enter your age: ");
  scanf ("%d",&i);
  printf ("Mr. %s , %d years old.\n",str,i);
  printf ("Enter a hexadecimal number: ");
  scanf ("%x",&i);
  printf ("You have entered %#x (%d).\n",i,i);
  
  return 0;
}



// ascii linux:

#include <iostream>
int main(){
	int num = 254;
	char a = char(num), b = char(254);  

	// char c=254; // only in windows.

	std::cout<<a<<b<<std::endl;
	return 0;
}
-------------------->>> use elif : use else if :

#include <iostream>
using namespace std;
int main ()
{
	int a = 3;
	if (a == 1) cout << "a"<<endl;
	else if (a == 2) cout << "b"<<endl;
	else if (a == 3) cout << "c"<<endl;
	else cout << "d"<<endl;
	
  return 0;
}

OUTPUT:
c
----------------------------------------------------
//use of flag or bandera in spanish
char band='f';
.....
......
if (xnumber >10){
   band ='v';
  }
//como un controlador.
---------------------------------------------------
//recuerda matrices
int nums[100][100];
//o la ya definida
int nums[2][3]={{1,2,3},{4,5,6}};

----------------------------------- get memory variable :

#include <iostream>
using namespace std;
int main ()
{
  char str = 'a';
  int integer = 12;
  float flt = 3.14;

  cout << "address of char   :" << (void *)&str <<endl;
  cout << "address of char   :" << static_cast<void *>(&str) << endl;

  cout << "address of integer   :" << &integer <<endl;
  cout << "address of flaot   :" << &flt << endl;

  return 0;
}

OUTPUT:
address of char   :0x3a53ffa6f
address of char   :0x3a53ffa6f
address of integer   :0x3a53ffa68
address of flaot   :0x3a53ffa64

--------------------- return an Array from function :

remember is that C++ does not advocate to return the address of a local variable to outside of the function so 
you would have to define the local variable as static variable.

#include <iostream>
#include <ctime>

using namespace std;

// function to generate and retrun random numbers.
int * getRandom( ) {

   static int  r[10];

   // set the seed
   srand( (unsigned)time( NULL ) );
   
   for (int i = 0; i < 10; ++i) {
      r[i] = rand();
      cout << r[i] << endl;
   }

   return r;
}

// main function to call above defined function.
int main () {

   // a pointer to an int.
   int *p;

   p = getRandom();
   
   for ( int i = 0; i < 10; i++ ) {
      cout << "*(p + " << i << ") : ";
      cout << *(p + i) << endl;
   }

   return 0;
}

---------------------
//una forma de ingresar una cadena d caracteres muy buena.
//para eso usaremos:
char name[40];  ###es importante hacer esto o no funca el codigo.

cin.getline(name,40,'\n');   //  ES MEJOR PARA CHAR CON ARRAY.

getline(cin,variable_a_guardar,'\n');  // ES MEJOR PARA STRINGS.

//en donde va "name" es donde pondremos la variable char donde queramos digitar los caracteres, en donde dice "40" es la cantidad d espacios a dar a esa char
//donde dice "\n" es para con q tecla finalizar esta forma de entrada.


------------ use math.h : use math :

https://www.cplusplus.com/reference/cmath/

pow(2, 8) // 256
sqrt(9) // 3

atan(y/x); // range: [-pi/2, pi/2]

atan2(y,x) // return a reply in radians  // range of atan2: [-pi, pi]
atan2(y,x) * 180 / 3.1416 // return a reply in radians and we converted to degrees

#include <iostream>
#include <math.h>
using namespace std;
#define PI 3.14159265

int main(){
	cout<<atan2(6,4)*180/PI<<endl;
	cout<<atan2(7,-3)*180/PI<<endl;
	cout<<atan2(-2,2)*180/PI<<endl;
	cout<<atan2(-3,-5)*180/PI<<endl;
	cout<<atan2(-2,2)*180/PI + 360<<endl;
	cout<<atan2(-3,-5)*180/PI + 360<<endl;
	return 0;
}

OUTPUT:
56.3099
113.199
-45
-149.036
315
210.964


float theta, angle = 35;
theta = angle * 3.1416 / 180.0;
sin(theta); // recieve a angle in radians and return and angle in radiands.
cos(theta); // recieve a angle in radians and return and angle in radiands.


------------ use string.h : dtype string and functions :

1.strlen(variable); \\o sea la longitud de la cadena.

2.strcpy(variable, variable o palabra); // strcpy(name, "Carlos");

3.if(strcmp(palabra1,palabra2) ==0); \\para compara si son iguales, exiten(==0 (para si son iguales, != 0 (si son diferentes), <0 o >0 ( para ver si es mayor o menor alfabeticamente))
--ejemplo: if(strcmp(alex,pedro) <0){cout<<pedro<<"es mayor alfabeticamente<<endl;}

4.strcat(p1,p2); \\pues "strcat" une candenas ya hechas, parecido a strcpy pero strcpy solo copea y elimina la cadena que se va a copiar al la varible y mete la nueva copiada.
\\en strcat concatena, une las candemas sin eliminar ningun char como lo haria strcpy que elimina la base.

#include<string.h>
#include<stdlib.h>
using namespace std;
char letra(char *le);
int main(){
	char name[10]="marco",name2[10]="alex";

	strcat(name,name2);
	cout<<name<<endl;     \\marcoalex

	strcpy(name,name2);
	cout<<name<<endl;     \\alex

	system("pause");
	return 0;
}

5.strrev(palabra_a_digitar) \\cadena alrevez.
-modo normal para dar reversa a una cadena:

int main(){
	int f=0;
	char name2[10]="alexander",n[10];
	for(int i=strlen(name2)-1;i>=0;i=i-1){
		n[f]=name2[i];
		f++;
	}
	cout<<"\n"<<name2<<"\n"<<n<<endl;


	system("pause");
	return 0;	
}

-para verificar si es palindromo:

#include<iostream>
#include<string.h>
#include<stdlib.h>
using namespace std;
char letra(char *le);
int main(){
	int f=0;
	char name2[10],n[10];
	cin>>name2;
	strcpy(n,name2);
	strrev(name2);
	cout<<n<<" ---> "<<name2<<endl;
	if(strcmp(name2,n)==0){cout<<" palindromo "<<endl;}
	else{cout<<" no es."<<endl;}

	system("pause");
	return 0;
	
}

6.strupr(palabra_A_pasar_a_mayuscula); //PARA UNA CADENA

6.1 // PARA UNA LETRA O CHAR USAREMOS:

char resp = 'a';
resp = toupper(resp); // 'A'
// or
char resp = 'a';
resp_upper = resp - 32;  // a: 97 -> A:65 ascii code


7.strlwr(palabra_a_pasar_a_minuscula);

7.1// PARA UNA LETRA O CHAR USAREMOS:

char resp = 'A'
resp = tolower(resp); // 'a'
// or
char resp = 'A';
resp_upper = resp + 32;  // A: 65 -> a:97 ascii code


// dtype string :

// example 1:
#include <iostream>
#include <string>

using std::cout; using std::endl;
using std::copy; using std::string;

int main() {
    string string1("Starting string ");
    string string2("end of the string ");

    cout << "string1:  " << string1 << endl;
    string1 += string2;
    cout << "string1:  " << string1 << endl;

    return EXIT_SUCCESS;
}
// OUTPUT:
string1:  Starting string
string1:  Starting string end of the string


// Example 2:
#include <iostream>
#include <string>

using std::cout; using std::endl;
using std::copy; using std::string;

string concTwoStrings(const string &s1, const string& s2)
{
    return s1 + s2;
}

int main() {
    string string1("Starting string ");

    string string2 = concTwoStrings(string1, " conc two strings");
    cout << "string2: " << string2 << endl;

    return EXIT_SUCCESS;
}
//OUTPUT:
string2: Starting string  conc two strings



//Example 3 : USE APPEND:
#include <iostream>
#include <string>

using std::cout; using std::endl;
using std::copy; using std::string;

int main() {
    string string("Temporary string");

    string.append(" appended sequence");
    cout << string << endl;

    return EXIT_SUCCESS;
}
//OUPUT:
Temporary string appended sequence


//Example 4 :
#include <iostream>
#include <string>

using std::cout; using std::endl;
using std::copy; using std::string;

int main() {
    string string1("Starting strings");
    string string2("end of the string");

    string1.append(" ").append(string2).append("\n");
    cout << string1;

    return EXIT_SUCCESS;
}
//OUTPUT:
Starting string end of the string


------------------------- use atoi, atofm etc : char to int, string to int : etc :

// ago form:

// convertir un int a char, char a int, float, etc.

int a=3;
char a_char = (char)a;
int b = (int)a_char;

float a=3.5;
char a_char = (char)a;
int b = (int)a_char;

// with ascci:
char a = '9';
int b = (int)arr_c[i] - 48;  // the numbers chars in ASCII begin in 48 ('9' -> 57 - 48 -> 9).

char a = '9';
int b = arr_c[i]-'0'; // ASCII letter 'num' to num.



// new form :

#include<stdlib.h>
char num[]="123"
int numero_integer;
float numero_float;
numero_integer = atoi(num);  \\123     integer 
numero_float = atof(num);   \\123.00   float

// string to int:
string numero = "123";
int int_numero = atoi(numero.c_str());  // numero.c_str(): string to char_array object.

8-------> 
programa para contar cuantas vocales exiten en la cadena:

#include<iostream>
#include<string.h>
#include<stdlib.h>
using namespace std;
int main(){
	int numa=0,nume=0,numu=0,numo=0,numi=0;
	char name[20];
	cin.getline(name,20,'\n');
	for(int i=0;i<strlen(name);i++){
		switch(name[i]){
			case 'a':numa++;break;
			case 'u':numu++;break;
			case 'o':numo++;break;
			case 'i':numi++;break;
			case 'e':nume++;break;
		}
	}
	cout<<'a'<<" --> "<<numa<<endl;
	cout<<'u'<<" --> "<<numu<<endl;
	cout<<'o'<<" --> "<<numo<<endl;
	cout<<'i'<<" --> "<<numi<<endl;
	cout<<'e'<<" --> "<<nume<<endl;
	

	system("pause");
	return 0;	
}
9--->para imprimir con format o codigo ASCCI usaremos la funcion "printf();"
ejemplo:

	for(int i=1;i<=50;i++){
		for(int f=1;f<=50;f++){
			for(int g=1;g<=50;g++){
				if(i*i==f*f+g*g){
					printf("%d%c = %d%c + %d%c",i,253,f,253,g,253);cout<<endl;
				}
			}
		}
	}
pagina para saber sobre este tema: http://www.it.uc3m.es/pbasanta/asng/course_notes/input_output_printf_es.html

10------>

PUNTEROS:
& = direccion
* = contenido

ejemplo:
12 //0x24fe3c   es su direccion.
8 //0x24fe38         ||

a = 0x24fe3c
b = 0x24fe38

*a = 12
*b = 8
//
	cin>>a;cin>>b;
	cout<<" direc: "<<&a<<" - "<<&b<<endl;
	cout<<" the sum is: "<<orden(&a,&b)<<endl;
//

	int orden(int *a,int *b){
		return *a + *b;
	}
// print:
 direc: 0x24fe3c - 0x24fe38
 the sum is: 20

ejemplo de cambio de valor enviados por funcion:

void cambio(int *,int *);  //prototipo para resivir 2 direcciones "&".

int main(){
	int n1=17,n2=5;

	cout<<n1<<endl;  //salida 17
	cout<<n2<<endl;  //salida 5

	cambio(&n1,&n2);     //se envia la direccion de las varibles "n1" y "n2".

	cout<<n1<<endl;  //salida 5
	cout<<n2<<endl;	 //salida 17

	getch();
	return 0;
}

void cambio(int *val1,int *val2){
	int aux;

	aux = *val1;       //aux almacena el contenido de la direccion n1      FORMULA: " * " + " direccion " = contenido de la direccion.
	*val1 = *val2;     //el nuevo contenido de n1 sera n2
	*val2 = aux;       //el contenido nuevo de n2 sera aux que contiene el valor de n1
}


11----->

para el uso de espacios usaremos:
#include<iomanip>
cout<<setw(cantidad_de_espacios_a_saltar)<<" hola"<<endl;

11 ------------- >>> types of cin : use cin : string cin : types cin :

#include <iostream>
#include<conio.h>

using namespace std;
int main ()
{
	char name0, *name1 = new char[30], name2[30];
	string name3, name4;
	
	cout << "0: "; cin>>name0;   // one char
	fflush(stdin);
	
	cout << "1: "; cin>>name1;  // severals chars(30), but without spaces.
	fflush(stdin);
	
	cout << "2: "; cin.getline(name2,30,'\n'); // severals chars until 30.
	fflush(stdin);
	
	cout << "3: "; getline(cin, name3); // severals words
	fflush(stdin);
	
	cout << "4: "; cin>>name4;  // severals words, but without spaces.
	
	cout << "name 0: " << name0<<endl;
	cout << "name 1: " << name1<<endl;
	cout << "name 2: " << name2<<endl;
	cout << "name 3: " << name3<<endl;
	cout << "name 4: " << name4<<endl;
	
	delete [] name1;  // this is neccesary.
  return 0;
}

OUTPUT:

0: a
1: bc
2: d e
3: f g
4: h i
name 0: a
name 1: bc
name 2: d e
name 3: f g
name 4: h


12------> clean the buffer : clean the data of cin :

#include<conio.h>

PRIMER PUNTO \\ fflush(stdin);
 
sirve para limpiar la memoria del teclado enviada al ordenador o pc, para que los envios sean más limpios y no ocasionen problemas en un futuro.
un ejemplo seria el uso del cin.getline(bla_bla_y_'\n') ese '\n' es para el salto de linea, una vez usado el cin.getline('\n') ese comando de salto de linea
'\n' ya dejara se ser util, o sea si pones un cin.getline(\n) y más abajo un cin.getline(\n) el segundo no funcionara o estara inavilitado y pasara
como si ya termino la funcion.
conclu: usar fflush(stdin);  para tener un mejor uso y menor problematica en memoria de teclado para liberar los buffers.
buffer: pequeña memoria que guarda las teclas que introduces en el teclado.

SEGUNDO PT TAMBIEN SE PODRIA USAR EL " cin.ignore(); "

13------>  STRUCTURAS :: STRUCT :: STRUCTS ::

\\uso de struct {}: sirve para crear variables definidas, pero sin crearlas otra vez, solo crearemos un objeto más, es parecido a las clases.
#include<iostream>
#include<conio.h>
using namespace std;
struct identidad{
	int dni,age;
	char ciudad[20],sexo;
	float altura;
struct datos{
	char name[30];
	struct identidad persona;
}user,user2,user3;
int main(){
	cout<<" Enter 1 Name: ";
	cin.getline(user.name,30,'\n');
	cout<<" Enter 1 Age: ";
	cin>>user.identidad.age;      \\ingresando dentro de la estructura dato y luego ingrea a identidad.
	fflush(stdin);
	cout<<" --------------------- "<<endl;
	cout<<" Enter 2 Name: ";
	cin.getline(user2.name,30,'\n');
	cout<<" Enter 2 Age: ";
	cin>>user2.identidad.age;
	fflush(stdin);
	cout<<" --------------------- "<<endl;
	cout<<" Enter 3 Name: ";
	cin.getline(user3.name,30,'\n');
	cout<<" Enter 3 Age: ";
	cin>>user3.identidad.age;
	
	
	cout<<"\n Cortes comerciales udurururu: \n"<<endl;
	
	cout<<" 1 Name: "<<user.name<<endl;
	cout<<" 1 Age: "<<user.identidad.age<<endl;
	
	cout<<" 2 Name: "<<user2.name<<endl;
	cout<<" 2 Age: "<<user2.age<<endl;

	cout<<" 3 Name: "<<user3.name<<endl;
	cout<<" 3 Age: "<<user3.age<<endl;
	getch();
	return 0;
}

\\\\\\ y una forma más eficiente y con menos lineas seria:

#include<iostream>
#include<conio.h>
using namespace std;
struct datos{
	int age,dni;
	char pais[20],ciudad[20],sexo;
};
struct curiculo{
	char carrera[30],name[30];
	struct datos ciudadano;
}personal[2];              \\ arreglo de estructura.
int main(){
	int i;
	for(i=0;i<2;i++){
		cout<<" Enter name: ";cin.getline(personal[i].name,30,'\n');fflush(stdin);
		cout<<" Enter age: ";cin>>personal[i].ciudadano.age;fflush(stdin);
		cout<<" Enter career: ";cin.getline(personal[i].carrera,30,'\n');fflush(stdin);
		cout<<" Enter country: ";cin.getline(personal[i].ciudadano.pais,20,'\n');fflush(stdin);
	}
	for(i=0;i<2;i++){
		cout<<" Name: "<<personal[i].name<<endl;
		cout<<" Age: "<<personal[i].ciudadano.age<<endl;
		cout<<" career: "<<personal[i].carrera<<endl;
		cout<<" Country: "<<personal[i].ciudadano.pais<<endl;
	}
	return 0;
}

#include<iostream>
#include<conio.h>
using namespace std;
struct Persona {
	char nombre[20];
	int edad;
	
}persona1= {"Alejandro", 20}, persona2 = { "Ruperto", 15 };

int main()
 {
	cout << " Nombre1: " << persona1.nombre << endl;
	cout << "Edad1 : " << persona1.edad << endl;

	cout << " Nombre1: " << persona2.nombre << endl;
	cout << "Edad1 : " << persona2.edad << endl;
}

// STRUCT CON SUS FUNCIONALIDADES ::

#include<iostream>
#include<conio.h>
using namespace std;

struct datos{
	int num;
	void enter_data();
	void show_data();
};

void datos::enter_data(){
	cout<<" enter number: ";
	cin>>num;
}

void datos::show_data(){
	cout<<" the data is: "<<num<<endl;
}

int main(){
	datos &yo = *new datos();
	yo.enter_data();
	yo.show_data();
	
	getch();
	return 0;
}

-> // STRUCT Y THIS JUNTO A ARCHIVOS .H : MODULOS C++:

THIS = ES LA QUE SI ES LLAMADA EN UNA CLASE O STRUCT SIGNIFICA QUE EL ELEMENTO QUE SE LLAMA ES DE ESTA CLASS O STRUCT EJEMPLO:

.H = PARA CREAR MODULOS DEBEMOS GUARDAR EL FILE NORMALMENTE PERO BORRAN EL CPP QUE ES EL APLICATIVO  Y PONEN .H : h, que significa "standard input-output header" (cabecera estándar E/S), es el archivo de cabecera que contiene las definiciones de las macros, las constantes, las declaraciones de funciones de la biblioteca estándar del lenguaje de programación C para hacer operaciones, estándar, de entrada y salida.
FUNCIONA PARA STRUCTS Y CLASS Y TAMBIEN PARA FUNCIONES GLOBALES.

string name;
this->name = name;  //el primer name es de la class o struct el segundo es un enviado, nuevo, varible creada etc.

-----NAME DEL ARCHIVO = "fecha.h" en .h se guarda macros, declaraciones, etc.

#include <iostream>
using namespace std;
struct fecha
{
    int dia;
    int mes;
    int annio;
    void asignar(int,int,int);
    void ingresarFecha();
    void mostrarFecha();

};
void fecha::asignar(int dia,int mes,int annio){
	this->dia=dia;
	this->mes=mes;
	this->annio=annio;
}
void fecha::ingresarFecha()
{
	cout<<" Nacimiento::"<<endl;
	cout<<" ingrese dia: ";
    cin >> dia;
    cout<<" ingrese mes: ";
    cin >> mes;
    cout<<" ingrese annio: ";
    cin >> annio;
}
void fecha::mostrarFecha(){
	cout<<"Nacimiento: "<<dia<<"/"<<mes<<"/"<<annio<<endl;
}

------- name = "pareja.h" :

#include "fecha.h"      //COMO SE VE SE IMPORTA EL MODULO FECHA.H.
#include <iostream>
#include <string>
using namespace std;

struct Pareja
{
    		//datos
    int edad;
    string nombre;
    char level;
    int celular;
    fecha fechanacimiento;
    		//operaciones
    void asignar(int, char, int, string,fecha);
    void mostrar();
    void ingresar();
};
void Pareja::asignar(int edad, char level, int celular, string d,fecha f)
{
    this->edad = edad;
    this->level = toupper(level);
    this->celular = celular;
    this->nombre = d;
    this->fechanacimiento = f;
}
void Pareja::mostrar()
{
	cout<<"\n DATOS\n\n";
    cout << "Edad: " << edad << endl;
    cout << "Nombre: " << nombre << endl;
    cout << "Nivel: " << level << endl;
    cout << "Celular: " << celular << endl;
    fechanacimiento.mostrarFecha();
}
void Pareja::ingresar()
{
    int a = 0, c = 0;
    char b = ' ';
    string n;
    cout << " Ingresar edad: ";
    cin >> a;
    c = getchar();
    cout << " Ingresar nombre: ";
    getline(cin,n,'\n');

 

    cout << " Ingresar Nivel: ";
    cin >> b;
    cout << " Ingresar celular: ";
    cin >> c;
    fecha f;
    f.ingresarFecha();
    this->asignar(a, b, c,n,f);
}

---- SOURCE O SUCURSAL O EL APLICATIVO EN .CPP ::

#include<iostream>
#include "pareja.h"   // SE IMPORTA EL MODULO ANTERIOR.
using namespace std;
int main(){
	Pareja yo,tu;
	
	yo.ingresar();
	yo.mostrar();
	
	fecha hoy={12,5,2006}, ayer={4,12,2019};        //OTRA FORMA DE ASIGNAR ATRIBUTOS DE UNA STRUCTURA.

	tu.asignar(13,'b',3213134,"paola",hoy);
	tu.mostrar();
	
	ellos.asignar(78,'c',586939439,"hermes",ayer);
	ellos.mostrar();

	return 0;
}


---- AHORA UNA CLASE NAME =  "paciente.h" :

#include<iostream>
#include "pareja.h"
using namespace std;
class paciente{
	private:
		int dni;
		Pareja persona;
	public:
		void todo();
		void show_todo();
};

void paciente::todo(){
	cout<<" Ingresa DNI: ";cin>>dni;
	persona.ingresar();
}
void paciente::show_todo(){
	persona.mostrar();
	cout<<"DNI : "<<dni<<endl;
}

----- APLICATIVO EN .CPP DE TODO :

#include<iostream>
#include "paciente.h"
using namespace std;
int main(){
	paciente alex;
	alex.todo();
	alex.show_todo();
	return 0;
}

14------>
#para crear un objeto seria así:
nombre_de_la_clase  nombre_Del_objeto;     \\barra bar;
##para definir algo al en el programa se usara "#define lo_que_quieres_definir valor_a_dar  \\ #define alex 18
15------>
\\para enumerar una array o algo parecido a memoria de espacio usaremos enum:
int main(){
	enum dias { domingo, lunes, martes, miercoles, jueves, viernes, sabado };
	for (int d = domingo; d <= sabado; d++) cout << d;       \\la salida sería: 0 1 2 3 4 5 6
	return 0;
}
\\si ponemos en domingo =1 el enumerate comenzara en 1, si lo ponemos en 7 el enumerate comenzara en 7
\\donde sea que coloquemos un valor en la variable comenzara esde ese valor dado:(ejem) 
int main(){
	enum dias { domingo=1, lunes, martes, miercoles, jueves=105, viernes, sabado };
	for (int d = domingo; d <= sabado; d++) cout << d;       \\la salida sería: 1 2 3 4 105 106 107
	return 0;
}

16-------->

\\ una de las otras formas de mostrar la cadena pero en reversa es:
int main(){
	char c[10],c2[10],cade;
	cin>>c;
	for(int i=0;i<=strlen(c);i++){
		cade=c[strlen(c)-i-1];
		c2[i]=cade;
	}
	cout<<" nombre: "<<c<<endl;
	cout<<" reverse: "<<c2<<endl;
}

17----------> COLOR CONSOLE : COLOR CHAR : COLOR STRING :

// CODE ANSI : https://en.wikipedia.org/wiki/ANSI_escape_code

// COLOR CHAR linux:
#include <iostream>

#define RESET   "\033[0m"
#define BLACK   "\033[30m"      /* Black */
#define RED     "\033[31m"      /* Red */
#define GREEN   "\033[32m"      /* Green */
#define YELLOW  "\033[33m"      /* Yellow */
#define BLUE    "\033[34m"      /* Blue */
#define MAGENTA "\033[35m"      /* Magenta */
#define CYAN    "\033[36m"      /* Cyan */
#define WHITE   "\033[37m"      /* White */
#define BOLDBLACK   "\033[1m\033[30m"      /* Bold Black */
#define BOLDRED     "\033[1m\033[31m"      /* Bold Red */
#define BOLDGREEN   "\033[1m\033[32m"      /* Bold Green */
#define BOLDYELLOW  "\033[1m\033[33m"      /* Bold Yellow */
#define BOLDBLUE    "\033[1m\033[34m"      /* Bold Blue */
#define BOLDMAGENTA "\033[1m\033[35m"      /* Bold Magenta */
#define BOLDCYAN    "\033[1m\033[36m"      /* Bold Cyan */
#define BOLDWHITE   "\033[1m\033[37m"  


int main() {
  std::cout << GREEN<< "Hello World!\n"<<RESET;
  std::cout << YELLOW << "Hello World!"<<RESET;
}


// BLOCK COLOR:

#define RESET   "\033[0m"
#define BLOCK_BLACK   "\033[40m"      
#define BLOCK_RED     "\033[41m"     
#define BLOCK_GREEN   "\033[42m"      
#define BLOCK_YELLOW  "\033[43m"     
#define BLOCK_BLUE    "\033[44m"    
#define BLOCK_MAGENTA "\033[45m"      
#define BLOCK_CYAN    "\033[46m"    
#define BLOCK_WHITE   "\033[47m"      

#define BLOCK_LIGHT_BLACK   "\033[100m"     
#define BLOCK_LIGHT_RED     "\033[101m"      
#define BLOCK_LIGHT_GREEN   "\033[102m"      
#define BLOCK_LIGHT_YELLOW  "\033[103m"      
#define BLOCK_LIGHT_BLUE    "\033[104m"     
#define BLOCK_LIGHT_MAGENTA "\033[105m"     
#define BLOCK_LIGHT_CYAN    "\033[106m"      
#define BLOCK_LIGHT_WHITE   "\033[107m"   

#include <iostream>
using namespace std;

int main(void)
{
  int i, j, n;
  system(" ");
  for (i = 0; i < 11; i++) {
    for (j = 0; j < 10; j++) {
      n = 10*i + j;
      if (n > 108) break;
	  cout <<"\033["<<n<<"m "<<n<<"\033[m";
    }
    printf("\n");
  }
  system("pause");
  return 0;
}


// COLOR CHAR windows:
#include <iostream>
#include <conio.h>
#include <windows.h> //set color
using namespace std;

//COLORS LIST
//1: Blue
//2: Green
//3: Cyan
//4: Red
//5: Purple
//6: Yellow (Dark)
//7: Default white
//8: Gray/Grey
//9: Bright blue
//10: Brigth green
//11: Bright cyan
//12: Bright red
//13: Pink/Magenta
//14: Yellow
//15: Bright white
//Numbers after 15 include background colors

void Color(int color)
{
 SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);
}

main(){
	Color(4);
	cout<<"red"<<endl;
	Color(2);
	cout<<"green"<<endl;
	Color(7);
	cout<<"reset color to default"<<endl;
 getch();
 return 0;
}


\\ COLOR CONSOLE
\\usos con la libreria " #include<windows.h> " :
system("pause"); \\para dar pausa a la pantalla.
system("cls"); \\limpia toda la ventana.
system("color f0");  \\para cambiar de color el fondo, osea de pantalla negra con letras blancas cambia a blanca con letras negras.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! COLOR !!!!!!!!!!!!!!!!!!!!!!!!!
ahora les traigo un biblioteca para C++ que te permite cambiar el color de la consola  .

#include<stdlib.h> // libreria para cambia color
void main(void) {
system ("color 9A" );//ejemplo
.
.
.
depues de eso tu codigo normal
.
.
..
en lineas puenteadas va tu codigo no mofique nada en tu codigo solo se modificara la consola 

}



color de consola :
0 = Negro
1 = Azul
2 = Verde
3 = Aguamarina
4 = Rojo
5 = Purpura
6 = Amarillo
7 = Blanco
8 = Gris
9 = Azul claro

color de texto:
A = Verde claro
B = Aguamarina claro
C = Rojo claro
D = Purpura claro
E = Amarillo claro
F = Blanco brillante


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! COLOR !!!!!!!!!!!!!!!!!!!!!!!!!

18 ---------------->>>  use sleep : use delay :

Sleep(10 000);  \\para que le de pausa unos 10 segundos, pudes poner 5000 y dara 5 segundos y asi segun tu logica.

\\otra forma de poner un tiempo para cambiar o seguir con el codigo es:

#include<stdio.h>
#include<stdlib.h>
 
main()
{
printf("Maravilla perdida");
    printf("El programa terminará en 10 segundos.\n");       
 
    delay(10000);                         
 
    return 0;
}


\\ para ocultar el cursor, funcion que se envia a int main();
void OcultarCursor(){
	HANDLE hCon;
	hCon = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO cci;
    cci.dwSize = 2;
    cci.bVisible = FALSE;
	SetConsoleCursorInfo(hCon, &cci);
	
}

void gotoxy(int x, int y){                              
    HANDLE hCon;                                         \\el gotoxy es una funcion que sirve para saber la poscicion o cordenadas
	hCon = GetStdHandle(STD_OUTPUT_HANDLE);          \\del marcador en la pantalla como las matrices, row and columns, x y y.
	COORD dwPos;
	dwPos.X = x;
	dwPos.Y = y;
	
	SetConsoleCursorPosition(hCon, dwPos);

} 

int main(){
	OcultarCursor();   \\se llama a la funcion, el cursor es la fechita o el | que aparece en la pantalla.
}

18---------->

\\ para mostrar por pantalla un texto y imprimirlo en cierta pocicion usaremos en gotoxy:
#include<iostream>
#include<conio.h>
#include "ubi.h"           \\"ubi.h" es la libreria creada por nosotros, dentro de ese archivo,Devc++, se encuentra "gotoxy(int x,int y);".
using namespace std;
int main(){
	gotoxy(40,20);      \\envia a los cursores a esa pocicion " 40 para x, & 20 para y ".
	cout<<" Hola"<<endl;
	return 0;
}

19---------->

\\ buenisa pagina para aprender ciertas funciones, solo falta buscar librerias.
http://www.casdreams.com/auladeinformatica/cet/comandos_de_c.htm

20 ---------------->   PASSWORD : CONTRASEÑA : KBHIT() : GETCH() : GET KEYS OF KEYBOARD : LINUX KEY :

// key :

#include<iostream>
#include<conio.h>

using namespace std;

int main(){
	while(true){
		if(kbhit()){
			char tecla = getch();
			cout <<"tecla: "<<tecla<<endl;
		}
	}

	return 0;
}


\\para escribir una cadena pero sin que se muestre el mensaje y salga "*"

#include<iostream>
#include<conio.h>
#include<string.h>
#define enter 13
using namespace std;
int main(){
	char contra[30]={""},c[30];
	int x=0;
	bool val=true;
	while(val==true){
		if(kbhit()){
			char letra=getch();
			switch(letra){
				case enter:val=false;break;
				default:cout<<"*";contra[x]=letra;x++;break;
			}
		}
	}
	cout<<"\n"<<contra<<"\n-----------------"<<endl;
	fflush(stdin);
	cin.getline(c,30,'\n');
	if(strcmp(contra,c)==0){
		cout<<" Welcome"<<endl;
	}
	else{
		cout<<" Error"<<endl;
	}
	
	return 0;
}

---FUNCION PARA UNA MEJOR GENERADORA DE PASSWORDS:
---RETORNA UNA CADENA.

char *genery_password(){
	char letra,dato[20];
	int i=0;
	do{
		if(kbhit()){
			char letra=getch();
			if(letra != 13){   // 13 in ascii is the ENTER
				cout<<"*";
				dato[i] = letra;
				i++;
			}
			else{
				for(int a=i;a<20;a++){
					dato[a] = NULL;
				}
				break;
			}
		}
	}while(true);
	
	return dato;
}

// WINDOWS :

#include <conio.h>
#include <iostream>
using namespace std;

#define KEY_UP    72
#define KEY_LEFT  75
#define KEY_RIGHT 77
#define KEY_DOWN  80

int main()
{
    int c, ex;

    while(1)
    {
        c = getch();

        if (c && c != 224)
        {
            cout << endl << "Not arrow: " << (char) c << endl;
        }
        else
        {
            switch(ex = getch())
            {
                case KEY_UP     /* H */:
                    cout << endl << "Up" << endl;//key up
                    break;
                case KEY_DOWN   /* K */:
                    cout << endl << "Down" << endl;   // key down
                    break;
                case KEY_LEFT   /* M */:
                    cout << endl << "Left" << endl;  // key left
                    break;
                case KEY_RIGHT: /* P */
                    cout << endl << "Right" << endl;  // key right
                    break;
                default:
                    cout << endl << (char) ex << endl;  // not arrow
                    break;
            }
        }
    }

    return 0;
}



// LINUX KEYS right, left, up , down:

#include <iostream>
#include <termios.h>
#define STDIN_FILENO 0
using namespace std;
int main()
{
// Black magic to prevent Linux from buffering keystrokes.
    struct termios t;
    tcgetattr(STDIN_FILENO, &t);
    t.c_lflag &= ~ICANON;
    tcsetattr(STDIN_FILENO, TCSANOW, &t);

// Once the buffering is turned off, the rest is simple.
    cout << "Enter a character: ";
    char c,d,e;
    cin >> c;
    cin >> d;
    cin >> e;
    cout << "\nYour character was ";
// Using 3 char type, Cause up down right left consist with 3 character
    if ((c==27)&&(d=91)) {
        if (e==65) { cout << "UP";}
        if (e==66) { cout << "DOWN";}
        if (e==67) { cout << "RIGHT";}
        if (e==68) { cout << "LEFT";}
    }
    return 0;
}

21-------------> :: USE TEMPLATE ::

// cuando no sabemos que clase de valor se enviara a una funcion usaremos el " template <class nombre_de_tipo_de_variblea_random> " ejemplo:

#include<iostream>
#include<stdlib.h>
using namespace std;
template <class val>      //crea el tipo de varible general.
void valor(val a);        //usamos el val q es el tipo de varible general.
int main(){
	int num;            //creamos las varibles,int,float,double.
	float num2;
	double num3;
	cout<<" enter number int: ";cin>>num;
	valor(num);
	cout<<" enter number float: ";cin>>num2;
	valor(num2);
	cout<<" enter number double: ";cin>>num3;
	valor(num3);
	system("pause");
	return 0;
}

template <class val>         //siempre poner el template antes de la funcion, es parecida como q la de arriba para el prototipo
void valor(val a){           //confirmamos la funcion 
	if(a<0){
		a*=-1;
	}
	cout<<" the value is: "<<a<<endl;
}

// otro ejemplo con el template, crea una varible T que puede usarce como funcion:

/*Ejercicio 6: Escriba una plantilla de función llamada maximo() que devuelva el valor 
máximo de tres argumentos que se transmitan a la función cuando sea llamada.
Suponga que los tres argumentos serán del mismo tipo de datos.*/

#include<iostream>
#include<conio.h>
using namespace std;

template <class T>
T maximo(T dato1, T dato2, T dato3);

int main(){
	char dato1='e',dato2='f',dato3='a';
	
	cout<<"El maximo valor es: "<<maximo(dato1,dato2,dato3);
	
	getch();
	return 0;
}

template <class T>
T maximo(T dato1, T dato2, T dato3){
	T max;
	
	if((dato1 > dato2) && (dato1 > dato3)){
		max = dato1;
	}
	else{
		 if((dato2>dato1) && (dato2>dato3)){
			max = dato2;
		}
		else{
			max = dato3;
		}
	}
	return max;
}

22------>

//recordar que en las funciones el "void" no retorna nada, asi que ser precavido en ese aspecto.
// cuando es un valor muy grande usaremos long pero para enteros, es como float=int equivale a double=long, pero long no da desimales grandes, sino enteros extensos.3jempl0_:
#include<iostream>
#include<conio.h>
using namespace std;
int pedirdatos();
void funpot(int x,int y);
int a,b;
int main(){
	pedirdatos();
	funpot(a,b);
	return 0;
}
int pedirdatos(){
	cin>>a;
	cout<<a<<" a la : ";
	cin>>b;
	
}
void funpot(int x,int y){
	long val=1,i;
	for(i=0;i<y-1;i++){
		val*=x;
	}
	printf("%d ** %d = %d",a,b,val);
}

23------->

//enviar parametros por referencia, donde se pueden devolver valores multiples mediante la direccion de memoria, ejemplo:

#include<iostream>
#include<stdlib.h>
using namespace std;
void calcular(int x, int y,int&,int&);            //funcion para recivir 2 valores y 2 direcciones
int main(){
	int num1=3,num2=9,sum,pro;
	calcular(num1,num2,sum,pro);                // se envia 4 parametros normalmente 
	cout<<" la suma es: "<<sum<<endl;           //la suma es: 12    //la memoria de "sum" se cambio por la suma de num2+num2, los mismo aplica con la memoria de "pro"
	cout<<" el producto es: "<<pro<<endl;       //el producto es: 27 
	system("pause");
	return 0;
}

void calcular(int x,int y,int& z,int& w){    //recive dos parametros normales y 2 direcciones( las direcciones se definen por el "&" ) 
	z=x+y;          //"z" es una direccion junto a "w"
	w=x*y;          //con este metodo podremos devolver valores multiples.
}

//tecnica en la funcion para ver si el valor enviado es equivalente a cuantos dolares se puede dar por el valor enviado de cien etc...
/*Ejercicio 8: Escriba una función nombrada cambio() que tenga un parámetro en número
entero y seis parámetros de referencia en número entero nombrados cien, cincuenta,
veinte, diez, cinco y uno, respectivamente. La función tiene que considerar el
valor entero transmitido como una cantidad en dólares y convertir el valor en el número
menor de billetes equivalentes. */

#include<iostream>
#include<conio.h>
using namespace std;

void cambio(int,int&,int&,int&,int&,int&,int&);

int main(){
	int valor,cien=0,cincuenta=0,veinte=0,diez=0,cinco=0,uno=0;
	
	cout<<"Digite un valor: ";
	cin>>valor;
	//Llamos a la funcion
	cambio(valor,cien,cincuenta,veinte,diez,cinco,uno);
	
	cout<<"Cantidad de billetes a entregar como cambio:"<<endl;
	cout<<"Cien: "<<cien<<endl;
	cout<<"Cincuenta: "<<cincuenta<<endl;
	cout<<"Veinte: "<<veinte<<endl;
	cout<<"Diez: "<<diez<<endl;
	cout<<"Cinco: "<<cinco<<endl;
	cout<<"Uno: "<<uno<<endl;
	
	getch();
	return 0;
}

void cambio(int valor,int& cien,int& cincuenta,int& veinte,int& diez,int& cinco,int& uno){
	cien = valor/100;           //divide en entero si no da, devuelve 0
	valor %= 100;                // residuo de la divion para q continue abajo
	cincuenta = valor/50;        
	valor %= 50;
	veinte = valor/20;
	valor %= 20;
	diez = valor/10;
	valor %= 10;
	cinco = valor/5;
	uno = valor%5;
}

//una en horas:
#include<iostream>
#include<stdlib.h>
using namespace std;

void tiempo(int ,int& x,int& y,int& z);

int main(){
	int num,seg=0,min=0,hour=0;
	cout<<" enter secons: ";cin>>num;
	tiempo(num,hour,min,seg);
	cout<<" the time is: "<<hour<<":"<<min<<":"<<seg<<endl;
	system("pause");
	return 0;
}

void tiempo(int val,int& x,int& y,int& z){
	x=val/3600;             // esta formula es muy buena a la hora de calcular ciertas diferencias.
	val%=3600;
	y=val/60;
	z=val%60;
}

24--------->
//AREGLOS A UNA FUNCION:
//para enviar arreglos a un funcion(ejemplo):

#include<iostream>
#include<stdlib.h>
using namespace std;

void cuadrados(int vec[],int );   //se crea el prototipo con un tipo de valor de vector y uno de cantidad.
void muestra(int vec[],int );

int main(){
	const int tama=5;          //const es una constante que sera inmutable en toda la funcion main.
	int vec[tama]={1,2,3,4,5};  //vector con tamaño en memoria 5 por el "tama" que es la constante entera ya antes definida.
	cuadrados(vec,tama);         //se envia el nombre del vector, no se pone corchetes se envia el valor dado, y tambien el tamaño del vector
	muestra(vec,tama);
	system("pause");
	return 0;
}

void cuadrados(int vec[], int ta){          
	for(int i=0;i<ta;i++){
		vec[i]*=vec[i];       //al momento de multiplicarse entre si para sacar su cuadrado SE GUARDA COMO UNA REFERENCIA EN MEMORIA VALOR DADO
	}                             // O SEA QUE LO QUE ENVIEMOS EN LOS ESPACIO DE MEMORIAQ DE "vec" SE ALMACENARA EN LA MISMA MEMORIA TIPO(vec[i] = direccion = &)
}                                     // Y LO QUE SE ALMACENE EN ESA DIRECCION SERA SU VALOR O CONTENIDO.
void muestra(int vec[], int ta){
	for(int i=0;i<ta;i++){       
		cout<<" "<<vec[i]<<endl;
	}
}

25--------->
// para verificar si un vector o array esta en orden:

int estaordenado(int vec[],int q){
	int con=0,i;                   
	while((con==0) && (i<q-1)){     //q-1 porque abajo en el if si sobre pasa la cantidad dara un error, tanto porque no existe un numero o es aglo perdido.(i=0,i=1.....i<q-q).
		if(vec[i]>vec[i+1]){     //verifica si el acutal es mayor siguiente, si eso pasa significa que no esta en orden Ascendente.
			con++;           //con++ aumenta para que salga del while y de como resultado que no esta ordenado, puede usarce como bandera.
		}
		i++;                     //aumentamos el i para que recorra el vector.
	}
	
	if(con==0){
		cout<<" The vector is in order. "<<endl;
	}
	else{
		cout<<" The vector isnt in order "<<endl;
	}
	return 0;
}

26---------->

//para enviar una matriz a una funcion usaremos esto:
void muestraMatriz(matriz[][camtidad_obligatoria_A_colocar],int ,int );   //es obligatorio enviar la longitud exacta de la matriz en la aprte de columnas, es algo que c++ puso como regla.
//es recomendable usar la cantidad de filas y columnas como una varible constante int "const int".(ejemplo):

#include<iostream>
#include<conio.h>
using namespace std;
void muestra(int ma[][3],int ,int );      //definiendo la matriz, la primera es de filas(no es obligatoria definir cuanttos espacios),
void cuadrada(int ma[][3],int ,int );     //la de columnas si es OBLIGATORIO definirlas, por eso se ve un "[3]" que dfine la parte interior a la primera o sea columnas.

int main(){
	const int fi=2;
	const int co=3;
	int matriz[2][3]={{1,2,3},{4,5,6}};
	muestra(matriz,fi,co);
	cuadrada(matriz,fi,co);        //se envia solo el nombre como en los vectores.
	cout<<" -----"<<endl;
	muestra(matriz,fi,co);
	return 0;
}

void muestra(int ma[][3],int f,int c){    //la funcion ya en si, si define igual que el prototipo.
	for(int i=0;i<f;i++){
		for(int j=0;j<c;j++){
			cout<<" "<<ma[i][j]<<" ";
		}
		cout<<endl;
	}
}

void cuadrada(int ma[][3],int f,int c){
	for(int i=0;i<f;i++){
		for(int j=0;j<c;j++){
			ma[i][j]*=ma[i][j];
		}
	}
}

27---------->

//para enviar structuras a una funcion usaremos como ejemplo:

#include<iostream>
#include<conio.h>
using namespace std;
struct people{      //se crea la estructura y el nombre de la estructura sera "people"
	char name[30];
	int age;
}per;    //el valor a ser llamado o sea la varible de esta estructura.

void datos();
void muestra(people); //se envia el nombre de la estructura creada como struct en este caso people

int main(){
	datos();
	muestra(per);   //se envia la variable de la estructura.
	getch();
	return 0;
}

void datos(){    //aqui es normalmente porque son varibles globales.
	cout<<" enter name: ";cin.getline(per.name,30,'\n');
	cout<<" enter age: ";cin>>per.age;
}

void muestra(people p){   //struct people enviada como variable y el valor a ser llamado en esta funcion sera "p" equivaldria a "per" pero ya sabesmos como son las funciones.
	cout<<"\n\n name: "<<p.name<<endl;
	cout<<" age: "<<p.age<<endl;
}

//otra forma de usar structuras seria:

#include<iostream>
#include<conio.h>
using namespace std;

struct datos{
	char compa[30];
	int megas;
};
datos plan;
void ingresar();

int main(){
	ingresar();
	datos mi=plan;
	cout<<mi.compa<<" - "<<mi.megas<<endl;
	return 0;
}

void ingresar(){
	cout<<" enter company: ";cin.getline(plan.compa,30,'\n');
	cout<<" enter megas: ";cin>>plan.megas;
}


//RECORDAR QUE CUANDO SE CREE UNA ESTRUCTURA ESA ESTRUCTURA YA ES UN TIPO DE DATO(EJEMPLO):

#include<iostream>
#include<conio.h>
using namespace std;

struct ejercicio{   //Creacion del titulo de la estructura "ejercicio"
	float num,pala;
}z1,z2;  //dos varibles creadas

void ingresar();
ejercicio resolver(ejercicio ,ejercicio );  //funcion de tipo "ejercicio" como tipo de varible.
void muestra(ejercicio );

int main(){
	ingresar();
	ejercicio res = resolver(z1,z2); //se crea una variblenueva de ejercicio llamada "res" que su valor sera el valor retornado por la funion resolver.
	muestra(res);
	return 0;
}

void ingresar(){
	cout<<" <1> "<<endl;
	cout<<" enter part real: ";cin>>z1.num;
	cout<<" enter part imaginary: ";cin>>z1.pala;
	
	cout<<" <2> "<<endl;
	cout<<" enter part real: ";cin>>z2.num;
	cout<<" enter part imaginary: ";cin>>z2.pala;
}

ejercicio resolver(ejercicio x,ejercicio y){   //funcion tipo ejercicio creada por el struct
	x.num += y.num;
	x.pala += y.pala;
	return x;    //retorna la variable "x" de la struct ejercicio
}

void muestra(ejercicio respuesta){
	if(respuesta.pala>0){
		cout<<" ===> "<<respuesta.num<<"+"<<respuesta.pala<<"(imaginary value)"<<endl;
	}
	else{
		cout<<" ===> "<<respuesta.num<<respuesta.pala<<"(imaginary value)"<<endl;
	}
}

//otro ejemplo:

#include<iostream>
#include<stdlib.h>
using namespace std;

struct fecha{
	int year,month,day;
}f1,f2;

void enter();
fecha major(fecha ,fecha );
void muestra(fecha );

int main(){
	enter();
	fecha fet = major(f1,f2);
	muestra(fet);
	system("pause");
	return 0;
}

void enter(){
	cout<<" <date 1> "<<endl;
	cout<<" enter year: ";cin>>f1.year;
	cout<<" enter month: ";cin>>f1.month;
	cout<<" enter day: ";cin>>f1.day;
	
	cout<<" <date 2> "<<endl;
	cout<<" enter year: ";cin>>f2.year;
	cout<<" enter month: ";cin>>f2.month;
	cout<<" enter day: ";cin>>f2.day;
}

fecha major(fecha x,fecha y){
	if(x.year==y.year){
		if(x.month==y.month){
			if(x.day==y.day){
				return x;
			}
			else{
				if(x.day>y.day){
					return x;
				}
				else{
					return y;
				}
			}
		}
		else{
			if(x.month>y.month){
				return x;
			}
			else{
				return y;
			}
		}
	}
	else{
		if(x.year>y.year){
			return x;
		}
		else{
			return y;
		}
	}
}

void muestra(fecha mo){
	cout<<" < "<<mo.day<<"/"<<mo.month<<"/"<<mo.year<<" >"<<endl;
}

28--------->
//recursividad, son las funciones o proccesos que dan respuesta respecto a respuestas.
//algunas funciones recursivas en c++:

int factorial(int x){
	if(x==0){
		x=1;
	}
	else{
		x*=factorial(x-1);
	}
	return x;
}

int suma_anterior(int n){
	if(n==0){
		return n;
	}
	else{
		return n+=suma_anterior(n-1);
	}
}

int potencia(int x,int y){
	if(y==0){
		return 1;
	}
	else{
		return x*=potencia(x,y-1);
	}
}

int fibonacci(int n){
	if(n<=1){
		return 1;
	}
	else{
		return fibonacci(n-1)+fibonacci(n-2);
	}
}


// IMPORTANTE: recuerda que para sacar el fibonacci de un numero sale atravez de la suma del numero -1 y el numero -2 ,(num-1)+(num-2). 
ejemplo >> //leelo de reveersa y comprenderas.
fibo(5) = fibo(4)+fibo(3)       //fibo(5)=8
fibo(4) =fibo(3)+fibo(2) 	//fibo(4)=5
fibo(3)=fibo(2)+fibo(1)         //fibo(3)=3
fibo(2)=fibo(1)+fibo(0)         //fibo(2)=2
fibo(1)=1                       //regla general o basica 0 = 1 en fibonacci.
fibo(0)=1                       //0+1=1

29------------>   **PUNTEROS***

-para guardar un puntero debemos crear el mismo tipo de varble(ejemplo):
int num=20,*dir_num;    //varible num que almacena 20; varible con contenido por el "*". el "*dir_num" es una puntero.
dir_num = &num;        //dir_num es una variable con contenido directo
cout<<dir_num<<endl;  //imprimira la direccion de num osea "0x213asd".
cout<<*dir_num<<endl;  //imprimira el contenido de memoria de "0x213asd" que es 20.

-Un vector y un puntero son combatibles entre si:
Primero antes que nada no es necesario usar un puntero para pasar como referencia con una matriz
, ya que las matrices y los punteros son compatibles entre ellos con sus castings...

#include<iostream>
#include <stdio.h>
using namespace std; 

void SetMt(int* a, int b[])  //recive como parametros a un puntero y un vector.
{
  a[0] = 2;    //se almacena en z[0] un 2.
  b[1] = 4;    //se almacena en z[1] un 4.
}

int main()
{

    // creamos un vector.
    int z[2];       // tamaño de z o del vector es 2.


    SetMt(z, z);    //se envia a la funcion el vector.  
                   //el vector en si es una direccion de memoria.

    cout<<"z ----> "<<z<<endl;      //salida:  z ----> 0x4a7040 

    printf("%d %d ", z[0], z[1]); // Salida: 24

}

Los vectores son punteros constantes. Un vector sin subindice es un puntero al primer elemento del vector.
Una matriz es un vector de vectores. (Ej: int M[3][3];) de manera que en cada elemento del primer vector "se cuelga" otro vector, pudiendo hacer así referencia a filas y columnas.
o sea que:
int x[]={11,12,13}, *dir;
dir=x;  // puntero -> 11   //primer elemento del vector o sea "11".

//enviar una funcion por puntero:

#include <iostream>
using namespace std;

bool functionA( int, int, bool (*)( int ) ); //Prototipo
bool functionB( int ); //Prototipo

void main()
{
    int x = 113, y = 226;
    if ( functionA( x, y, functionB ) )
		cout << "\nEl resultado es verdadero";
	else
		cout << "\nEl resultado es falso";
}

bool functionA( int param1, int param2, bool (*verificar)( int ) )
{
	if ( ( (*verificar)( param1 ) ) && ( (*verificar)( param2 ) ) )
		return true;
}

bool functionB( int param )
{
	if ( param > 100 )
		return true;
	else
		return false;
}


//otra forma de recorrer una array o vector con punteros seria:

#include<iostream>
#include<conio.h>
using namespace std;

void show(int *);   //prototipo con valores a enviar en punteros.

int main(){
	int vec[]={3,22,5,73,11,33};
	show(vec);  //envia sin subindices o sea al primer elemento del vector.
	getch();
	return 0;
}

void show(int *var){ 
	for(int i=0;i<6;i++){
		cout<<*var++<<endl;  //3-22-5-73-11-33.  //contenido de cada direccion.
		cout<<var++<<endl;  //direccion de meoria de cada valor en hexagecimal. 
	}
}

30----------->  VALORES NULOS - VALORES VACIOS - NULL - FOREACH : 

el uso de '\0' : 
Si pero por convencion se utiliza:

* 0 en el contexto de numeros enteros (tipo "int").
* NULL en el contexto de punteros.
* '\0' en el contexto de caracteres.

// ejemplo 1: Un puntero no constante a un dato constante.

#include <iostream>

void imprimeChars( const char * ); // prototipo

void main ()
{
    char cFrase[] = "Hola Mundo";
    imprimeChars( cFrase );
}

void imprimeChars( const char *ptrStr )
{
    for ( ; *ptrStr != '\0'; ptrStr++ ) //Sin inicialización
        std::cout << *ptrStr;
}

// ejemplo 2: 

#include<iostream>
#include<conio.h>
using namespace std;

void show(int *);

int main(){
	int vec[]={3,22,5,73,11};
	show(vec);
	getch();
	return 0;
}

void show(int *var){
	for(;*var!=0;var++){
		cout<<*var<<endl;  
	}
}

31----------->   ARREGLOS DINÁMICOS :: MEMORIA DINAMICA ::

//para especificar la cantidad de memoria exacta ha almacenar sin dejar espacios vacios usaremos : "new y delete".

para usar estos invocaremos jaajaja o llamaremos a la libreria "#include<stdlib.h>"

new: reserva el número de bytes solicitados por la declaracion.
delete: libera un bloque de bytes reservados con anterioridad.

ejemplo:

#include<iostream>
#include<conio.h>
#include<stdlib.h>  //para que podamos usar el "new" y "delete".
using namespace std;

void notas();
void show();

int i,quan,*vec;

int main(){
	notas();
	show();
	                 //siempre despues de un "new" usar el "delete" para liberar el espacio de memoria, recomendable al final del programa.
	delete[] vec;    //libera el espacio de memoria reservado por el puntero "vec".
	getch();
	return 0;
}

void notas(){
	cout<<" enter quantity of notes: ";cin>>quan;
	vec = new int[quan];  //crea el arreglo o vector con una cierta cantidad de espacios definidos por la varible "quan" y es almacenada en el punero "vec".
	for(i=0;i<quan;i++){
		cout<<i+1<<" enter note: ";cin>>vec[i];
	}
}

void show(){
	cout<<"\n Notes \n"<<endl;
	for(i=0;i<quan;i++){
		cout<<vec[i]<<" ---> "<<&vec[i]<<endl;
	}
}

//tambien se puede con palabraso chars:
//ejemplo.

#include<iostream>
#include<conio.h>
#include<stdlib.h>
#include<string.h>
using namespace std;

void palabra();
void contar_vocales(char *);

char *pala;

int main(){
	palabra();
	contar_vocales(pala);

	delete[] pala;
	getch();
	return 0;
}

void palabra(){
	pala = new char[20];
	cout<<" Enter prhase: ";
	cin.getline(pala,20,'\n');
	strlwr(pala);
	fflush(stdin);
}

void contar_vocales(char *p){
	int con=0;
	for(int i=0;i<strlen(p);i++){
		if('a'==*(p+i) || 'e'==*(p+i) || 'i'==*(p+i) ||'o'==*(p+i) || 'u'==*(p+i)){
			con++;
		}
	}
	cout<<"\n The quantity of vowels is: "<<con<<endl;
}


//recordar que un puntero se lleva bien con un arreglo por no decir que son casi parecidos.

una ayudita:

int *vector,cantidad=5;
for(int i=0;i<cantidad;i++){
	cin>>*(vector+i);     //introduce un valor en el puntero aumentado por el "i" pero en el contenido del puntero "*".
}

----> PUNTEROS ** PARA MATRICES :: 

#include<iostream>
#include<conio.h>
#include<stdlib.h>
using namespace std;
                     // prototipos
void enter_data();   
void show(int **);   // se envia un doble puntero o sea un puntero matriz.

int **matriz,i,f,rows,columns;

int main(){
	enter_data();
	show(matriz);
	

	for(i=0;i<rows;i++){              //la nueva forma de liberar la memoria sera haci.
		delete[] matriz[i];       
	}
	delete[] matriz;

	getch();
	return 0;
}

void enter_data(){
	cout<<"\n FASE OF DATA: \n"<<endl;
	cout<<" Enter quantity of rows: ";cin>>rows;
	cout<<" Enter quantity of columns: ";cin>>columns;
	
	matriz = new int *[rows];   \\cada espacio de memoria es un puntero o sea [0] = *puntero, [1] = *puntero. //Reservar memoria para las filas
	
	for(i=0;i<rows;i++) {     //Reservar memoria para las columnas
		matriz[i] = new int[columns];   //ahora crea memoria para un vector enviado a un puntero ya antes explicado.
	}      //  puntero[0] que es un puntero tendra una array o vector a su cargo " puntero = [array_cantidad_de_espacio_de_memoria] ".
	
	for(i=0;i<rows;i++){
		for(f=0;f<columns;f++){
			cout<<" -> enter number ["<<i<<"]["<<f<<"] = ";cin>>*(*(matriz+i)+f);  //recordar que siempre al almacenar un valor usaremos el operador "*" para que sea el nuevo contenido de esa direccion.
		}
	}
}

void show(int **val){
	cout<<"\n show of data:\n"<<endl;
	for(i=0;i<rows;i++){                
		for(f=0;f<columns;f++){
			cout<<" ["<<i<<"]["<<f<<"] = "<<*(*(val+i)+f)<<" -> "<<(val+i)+f<<endl;  // " *(*(matriz+i)+f) " es equivalente a " matriz[i][f] ". -> contenido.
		}         //en la primera contenido yla segunda direccion.                          // " ((matriz+i)+f) " es equivalente a " &matriz[i][f] ". -> direccion.
	}
	
	cout<<"\n Matriz\n"<<endl;
	
	for(i=0;i<rows;i++){
		for(f=0;f<columns;f++){
			cout<<" "<<*(*(val+i)+f);
		}
		cout<<endl;
	}
	
	cout<<"\n salida de simplemente matriz como puntero que seria [0][0]\n en codigoseria: cout<<**matriz;"<<endl;
	cout<<"\n ===> "<<**val<<" este valor es el contenido de la matriz de [0][0]"<<endl;	
   
        // recordar que cuando no tiene subindices se enviara la posicion 0, 
        // y como cada parte de puntero tiene otro puntero dentro se envia denuevo 0,en otra palabras -> [0][0]. 
}   
     
32 --------->

PUNTEROS A ESTRUCTURAS O STRUCT :

// el comando principal para usar en estructuras con puntero sera " -> " donde vendria a ser como el remplaso del " . "

#include<iostream>
#include<conio.h>
#include<stdlib.h>
using namespace std;

struct info{    //creamos el titulo del nuevo tipo de variable
	char name[30];
	int age;
}persona, *dir_persona = &persona;   //creamos primero un campo de varible y luego un puntero que le asignamos el la direccion de "persona" como varible.

void datos(info *);  //prototipos
void show(info *);   // recordar que cuando enviamos a una funcion usaremos el tipo de var creada o sea el titulo de la structura, o sea "info" que se envia en este caso.
                     //se envia el tipo de vaor que se enviara y especificar que sera un puntero "*". ejemplo "int *", "char *", "info *".
int main(){
	// otra forma de hacer lo anterior seria:

	info persona, *dir_persona;
	dir_persona = &persona;     //
	
	datos(dir_persona);
	show(dir_persona);
	
	getch();
	return 0;
}

void datos(info *val){
	cout<<"\n entry\n\n";                // como vemo usaremos el " -> " como remplazo del operador punto.
	cout<<" enter name: ";cin.getline(val->name,30,'\n');
	fflush(stdin);                       // liberamos la memoria del buffer.
	cout<<" enter age: ";cin>>val->age;  // normal sin puntero = "val.age" ; con puntero = "val->age".
}


void show(info *conte){
	cout<<"\n exit:\n\n";
	cout<<" name: "<<conte->name<<"\n age: "<<conte->age<<endl;
}

// si queremos enviar una array de struct  sera casi lo mismo: EJEMPLO

struct alumno{
	char name[30];
	int age;
	float nota;
}per[10], *dir_alum = per;   // como es un array solo enviamos el name proque envia ya en si la direccion y como no tiene sub indices envia la primera pocision.

void datos(alumno *);
void show(alumno *);

int quan;

int main(){
	datos(dir_alum);
	show(dir_alum);
	
	getch();
	return 0;
}

void datos(alumno *dat){
	cout<<"\n Entry\n\n";
	cout<<" quantity of students to value: ";cin>>quan;
	for(int i=0;i<quan;i++){
		fflush(stdin);
		cout<<"\n<"<<i+1<<"> estudent: \n";
		cout<<" enter name: ";cin.getline((dat+i)->name,30,'\n');
		cout<<" enter age: ";cin>>(dat+i)->age;             //el "dat+i" es el truco de sumar pocisiones de memoria ya lo sabes con ejemplos anteriores en punteros.
		cout<<" enter average: ";cin>>(dat+i)->nota;                    
	}
}

void show(alumno *watch){
	float major=0.0;
	int res;
	cout<<"\n Exit \n\n";
	for(int i=0;i<quan;i++){
		if((watch+i)->nota > major){
			major = (watch+i)->nota;
			res = i;
		}
	}
	
	cout<<" name: "<<(watch+res)->name<<"\n age: "<<(watch+res)->age<<"\n best average: "<<(watch+res)->nota<<endl;
}

33 -------------> PILAS C++ :

// las pilas una de las partes más importantes a acordar o saber es que "la ultima en entra es la primera en salir".
// LAST INPUT - FIRST INPUT

// formula para INGRESAR ELEMENTOS a una pila:

::VERSION 1::

#include<iostream>
#include<conio.h>
#include<stdlib.h>
using namespace std;

struct Nodo{
	int dato;
	Nodo *siguiente;
};

void datos();
void AddPile(Nodo *&,int);
void TakePile(Nodo *&,int &);

int num;

int main(){
	Nodo *pila  = NULL;
	int con=0;
	while(con<3){
		datos();
		AddPile(pila,num);
		con++;
	}
	while(pila!=NULL){
		TakePile(pila,num);
		if(pila != NULL){
			cout<<num<<","; 	// INPUT : 4 -6 -1 -15   OUTPUT : 15,1,6,4.
		}     
		else{
			cout<<num<<".";
		}
	}
	getch();
	return 0;
}

void datos(){
	cout<<" enter number: ";cin>>num;
}
void AddPile(Nodo *&pila,int number){
	Nodo *new_nodo = new Nodo();
	new_nodo->dato=number;
	new_nodo->siguiente=pila;
	pila=new_nodo;
	
	cout<<"\n the number "<<number<<" have been to add to the pila with succesfull\n\n";
}
void TakePile(Nodo *&pila,int &val){
	Nodo *aux = pila;
	val = aux->dato;
	pila = aux->siguiente;
	delete aux;
}

::VERSION 2:: BY ME O ALEXANDER O SEA YIOP XD

#include<iostream>
#include<conio.h>
using namespace std;

struct Nodo{
	int num;
	Nodo *next;
};

void add_pile(Nodo *&,int);
void show_element(Nodo *&,bool &);
int main(){
	Nodo *pila = NULL;
	bool can = true;
	
	add_pile(pila,4);
	add_pile(pila,22);
	
	while(can){
		show_element(pila,can);
	}
	
	delete pila;

	getch();
	return 0;
}

void add_pile(Nodo *&pila,int dato){
	Nodo *new_nodo = new Nodo();
	new_nodo->num = dato;
	new_nodo->next = pila;
	pila = new_nodo;
}

void show_element(Nodo *&pila,bool &val){
	
	if(pila != NULL){
		cout<<pila->num<<",";
		pila = pila->next;	
	}
	else{
		cout<<"inicio."<<endl;
		val = false;
	}
}

:: EJEMPLO 3 DE MENU INGRESANDO Y MOSTRANDO ELEMENTOS::

#include<iostream>
#include<conio.h>
using namespace std;

struct Nodo{
	int num;
	Nodo *next;
};

void add_pile(Nodo *&,int);
void show_element(Nodo *&,bool &);

int main(){
	Nodo *pila = NULL,*general = NULL;
	bool can = true;
	int num,op;
	
	while(1){
		cout<<" >-|-O.enter option: ";cin>>op;
		switch(op){
			case 1:
				cout<<" enter number: ";cin>>num;
				add_pile(pila,num);break;
			case 2:
				general = pila;
				while(can){
					show_element(pila,can);
				}
				pila = general;
				can = true;
				break;
			case 3:
				cout<<" you exit of the application."<<endl;
				return 0;  		//ES COMO SALIR, COMO ES UNA FUNCION SE PUEDE SALIR DE UNA PONIENDO RETURN.
			default: cout<<" no existe esa opcion."<<endl;
		}
	}

	delete pila;
	delete general;

	getch();
	return 0;
}

void add_pile(Nodo *&pila,int dato){
	Nodo *new_nodo = new Nodo();
	new_nodo->num = dato;
	new_nodo->next = pila;
	pila = new_nodo;
}

void show_element(Nodo *&pila,bool &val){	
	if(pila != NULL){
		cout<<pila->num<<",";
		pila = pila->next;	
	}
	else{
		cout<<"inicio."<<endl;
		val = false;
	}
}

34 ----------->>> ABS :
include<stdlib.h>
int num=-5,val=abs(num); //val=5

35 ------------>>> COLAS C++ : COLA C++ : TAIL C++ : TAILS C++ :

FRASE : FIRST INPUT -> FIRST OUTPUT .

//EJEMPLO 1 : ENTRADA Y SALIDA :

#include<iostream>
#include<conio.h>
#include<stdlib.h>    // PARA EL NEW Y DELETE.
using namespace std;

struct Nodo{		//STRUCT BASICA PARA PILAS,COLAS,LISTAS.
	int dato;
	Nodo *siguiente;
};

void add_cola(Nodo *&,Nodo *&,int);
bool cola_vacia(Nodo *);
void show_cola(Nodo *&,Nodo *&,int &);

int main(){
	Nodo *frente = NULL;  //INIALIZACION DE LA COLA PORQUE SIEMPRE ES VACIA AL INICIAR COMO EN LA VIDA REAL.
	Nodo *fin = NULL;
	int val;

	cout<<" enter number: ";cin>>val;
	add_cola(frente,fin,val);

	cout<<" enter number: ";cin>>val;
	add_cola(frente,fin,val);

	cout<<" enter number: ";cin>>val;
	add_cola(frente,fin,val);
	
	cout<<"\n Salida de los elementos de la cola:\n";

	while( frente != NULL){
		show_cola(frente,fin,val);
		if(frente != NULL){
			cout<<val<<", ";
		}
		else{
			cout<<val<<"."<<endl;
		}
	}
	
	getch();
	return 0;
}

void add_cola(Nodo *&frente, Nodo *&fin, int num){
	Nodo *nuevo = new Nodo();      //CREAMOS ESPACIO EN MEMORIA DINAMICO PARA NODO.
	nuevo->dato = num;             //AGREGAMOS SUS VALORES: INT, Y NULL PORQUE ACABA DE ENTRAR A LA COLA Y ATRAS DE EL NO HAY NADIE.
	nuevo->siguiente = NULL;
	
	if(cola_vacia(frente)){        //PARA VER SI NO HAY NADIE EN LA COLA ES EQUIVALENTE A "frente == NULL".
		frente = nuevo;        //A FRENTE QUE ES NULL LE DAMOS LA DIRECCION DE MEMORIA DE "NUEVO" QUE ES EL NODO CREADO.
	}
	else{                          //CASO CONTRARIO QUE NO ESTE VACIA LA COLA.
		fin->siguiente = nuevo;     // A "FIN" QUE ANTERIOR MENTE FUE EL PRIMER ELEMENTO QUE SU SIGUIENTE POR PUNTERO ES NULL SE CAMBIA SU DIRECCION A EL NUEVO NODO CREADO.
						// Y AL CAMBIAR EL SIGUIENTE DE FIN TMB POR DEFECTUO SE CAMBIA LA DE "FRENTE" PERO DEL NODO ALMACENADO DE NULL A EL NUEVO NODO.
	}
	
	fin = nuevo;
	// IMPORTANTE: 
//AL SER CREADO EL NUEVO NODO Y GRACIAS A LA LINEA DE "fin->siguiente = nuevo" ESO SOLO AFECTA A LA MEMORIA DE EL NUEVO NODO ANTERIOR
// Y AQUI "FIN" CAMBIA DE EL NODO ANTERIOR A UN NUEVO NODO O SEA A OTRO TIPO DE MEMORIA, CAMBIA DE INSTANCIA YA NO AFECTARIA A EL NODO ANTERIOR DE "fin->siguiente"
// PORQUE ESE ES OTRA DIRECCION DE MEMORIA, AHORA CON LA NUEVA ASIGNACION SU PUNTERO DE "FIN->SIGUIENTE" ES NULL NO ES EL NODO ANTERIOR "NUEVO" QUE FUE ASIGNADO EN EL "ELSE".

	// MEJOR EXPLICACION : 
||si cambias la direccion a la que apunta fin-> siguiente   cambias la direccion a la que apunta nuevo_nodo-> siguiente del nodo anteriormente creado.
||basicamente es como si asignaras     "nuevo_nodo->siguiente(anterior) = nuevo_nodo(actual)" 
||y asi el nodo anterior apunta al nodo nuevo.

	cout<<" el valor numerico \""<<num<<"\" se a agregado a la cola"<<endl;
}

bool cola_vacia(Nodo *frente){
	/*
			//forma tradicional y comun.
	if(frente = NULL){
		return true;
	}
	else{
		return false;
	}
			//forma avanzada y elegante.
	*/
	return (frente == NULL)? true : false;
}

void show_cola(Nodo *&frente, Nodo *&fin, int &num){
	num = frente->dato;    //SE CAMBIA MEDIANTE LA REFERENCIA EL VALOR DE "NUM".
	Nodo *aux = frente;	// AHORA "AUX" COMPARTE EL MISMO TIPO DE DATO DE MEMORIA QUE "FRENTE".
	
	if(frente == fin){	// SI "FRENTE" Y "FIN" TIENE EL MISMO TIPO DE MEMORIA. 
		frente = NULL;	// OSEA QUE LLEGATON AL FINAL O LA COLA ESTA VACIA.
		fin = NULL;
	}
	else{	//CASO CONTRARIO "FRENTE" CAMBIA DE MEMORIA CON EL NODO SUCESOR A ESTE.
		frente = frente->siguiente;     
	}
	delete aux;       //ELIMINAMOS O LIBERAMOS EL ESPACIO EN MEMORIA DE EL ANTERIOR "FRENTE".
}

//EJEMPLO 2 :

#include<iostream>
#include<conio.h>
#include<stdlib.h>
using namespace std;

struct Nodo{
	int dato;
	Nodo *siguiente;
};

void menu();
void add_cola(Nodo *&,Nodo *&,int);
void show_cola(Nodo *&,Nodo *&,int &);
void continue_cola(Nodo *&,Nodo *&);

int main(){
	
	menu();
	
	getch();
	return 0;
}

void menu(){
	Nodo *frente = NULL, *fin = NULL,*data1,*data2;
	int op,valor;
	do{
		cout<<"\n \tCOLA\n 1) add element\n 2) show elements\n 3) continue cola\n 4) exit\n Option: ";cin>>op;
		switch(op){
			case 1: 
				cout<<" -> Enter element: ";cin>>valor;
				add_cola(frente,fin,valor);
				break;
			case 2:
				if(frente != NULL){
					cout<<"\n SHOW ELEMENTS: ";
					data1 = frente;   //GUARDO LA MEMORIA DE CADA UNO EN OTRA VAR NODO PARA DESPUES RENOMBRARLAS DENUEVO.
					data2 = fin;
					while(frente != NULL){
						show_cola(frente,fin,valor);
						if(frente != NULL){
							cout<<valor<<", ";
						}
						else{
							cout<<valor<<"."<<endl;
						}
					}
					frente = data1;
					fin = data2;
				}
				else{
					cout<<"\n COLA VACIA\n\n";
				}
				break;
			case 3:
				if (frente == NULL){
					cout<<"\n COLA VACIA.\n\n";
				}
				else{
					continue_cola(frente,fin);	
				}
				break;
			case 4: break;
			default : cout<<"\n Doesnt exist that option.\n"<<endl;break;
		}
	}while(op!=4); //MEJOR FORMA DE HACER UN MENU, CON UN "DO-WHILE".
}

void add_cola(Nodo *&frente,Nodo *&fin,int num){
	Nodo *nuevo = new Nodo();
	nuevo->dato = num;
	nuevo->siguiente = NULL;
	if(frente ==NULL ){
		frente = nuevo;
	}
	else{
		fin->siguiente = nuevo;
	}
	fin = nuevo;
}
void show_cola(Nodo *&frente,Nodo *&fin,int &num){
	num = frente->dato;        //QUITE EL NODO AUX PORQUE NO DEBO ELIMINAR NADA.
	if(frente == fin){                // POR ESO TAMPOCO PUSE AL FINAL EL DELETE AUX.
		frente = NULL;
		fin = NULL;
	}
	else{
		frente = frente->siguiente;
	}
}

void continue_cola(Nodo *&frente,Nodo *&fin){
	Nodo *aux = frente;
	if(frente == fin){
		frente = NULL;
		fin = NULL;
	}
	else{
		frente = frente->siguiente;
	}
	delete aux;
} 


---- THE BEST FORM FOR ME IS :

#include<iostream>
using namespace std;

struct Node{
	int num;
	Node *next;
};

void add(Node *&,Node *&);
void show(Node *&,Node *&);
void show_all(Node *,Node *);

int main(){
	Node *front = NULL, *end=NULL;
	int op;
	do{
		cout<<" 1) add\n 2) show\n 3) show all\n 4) exit\n Enter option: ";cin>>op;
		switch(op){
			case 1:
				add(front,end);
				break;
			case 2:
				show(front,end);
				break;
			case 3:
				show_all(front,end);
				break;
			case 4:
				break;
			default:break;
		}
	}while(op != 4 );
	return 0;
}

void add(Node *&front,Node *&end){
	Node *new_n = new Node();
	int data;
	cout<<" Enter number to save: ";cin>>data;
	new_n->num = data;
	new_n->next = NULL;
	
	if(front == NULL){
		front = new_n;
	}
	else{
		end->next = new_n;
	}
	end = new_n;
}

void show(Node *&front,Node *&end){
	cout<<" the number : "<<front->num<<" : left the tail."<<endl;
	Node *aux = front;
	if(front == end){
		front = NULL;
		end = NULL;
	}
	else{
		front = front->next;
	}
	delete aux;
}

void show_all(Node *front,Node *end){
	while(front != NULL){
		cout<<" best: "<<front->num<<endl;
		front = front->next;
	}
}


°°°°---- COLA CON CLASES Y DATO PERSONA CLASS :°°°°° (ACLARACION DE ENVIAR POR REFERENCIA O SIN REFERENCIA.)

// RECORDAR QUE CUANDO TODO LO QUE ESTE DENTRO DE LAS FUNCIONES AL ENVIAR PUNTERO SE CAMBIARAN TODO EXCEPTO EL MISMO PUNERO EJEMPLO:

Ejemplo 1-- blabla(Node *algo){ 	//SIN REFERENCIA
	Node nuevo_nodo = new Node();
	algo->persona.edad = 19;    // CAMBIA EL CONTENIDO DE LA MEMORIA GRACIAS AL APUNTADOR, O SEA SOLO CAMBIARIA ESTO.
	algo = nuevo_nodo;          // NO CAMBIA EL NODO "algo" SOLO CAMBIA EN ESA INSTANCIA NO EN EL PROGRAMA.
}
Ejemplo 2-- blabla(Node *&algo){   	//CON REFERENCIA
	Node nuevo_nodo = new Node();
	algo->persona.edad = 19;    // CAMBIA EL CONTENIDO DE LA MEMORIA GRACIAS AL APUNTADOR.
	algo = nuevo_nodo;          // SI CAMBIA EL NODO "algo" PORQUE SE ESTA ENVIANDO EL NODO POR REFERENCIA YA NO COMO UN SIMPLE PUNTERO SINO UN PUNTERO QUE SERA MODIFICADO.
}

## EN CONCLUSION, EL CAMBIO DE VALORES DE LOS PUNTEROS POR PARAMETRO ES GRACIAS AL PUNTERO ESPECIAL POR REFERENCIA " & ".

#include<iostream>
using namespace std;

class Person{
	private:
		char name[30];
		int dni;
	public:
		void enter_data();
		void show_data();
		char *get_name(){
			return name;
		}
};

void Person::enter_data(){
	fflush(stdin);
	cout<<" Enter name: ";cin.getline(name,30,'\n');
	fflush(stdin);
	cout<<" Enter Dni: ";cin>>dni;
}
void Person::show_data(){
	cout<<" Name: "<<name<<endl;
	cout<<" Dni: "<<dni<<endl;
}

struct Node{
	Person im;
	Node *next;
};
class Tail{
	private:
		int quan,pos;
	public:
		Tail(){
			quan = 0;
			pos = 0;
		}
	void add(Node *&,Node *&);
	void advance(Node *&,Node *&);
	void show(Node *);
	void modificate(Node *);
};

int main(){
	Node *front = NULL, *end = NULL;
	Tail cola;
	int op;
	do{
		cout<<" 1) add\n 2) show\n 3) advance\n 4) modificate\n 5) exit\n option: ";cin>>op;
		switch(op){
			case 1:
				cola.add(front,end);break;
			case 2:
				cola.show(front);break;
			case 3:
				cola.advance(front,end);break;
			case 4:
				cola.modificate(front);
				break;
			case 5:break;
			default:cout<<"\n That option doesnt exist.\n";
		}
	}while(op != 5);
	return 0;
}

void Tail::add(Node *&front,Node *&end){
	Node *nuevo = new Node();
	nuevo->im.enter_data();
	nuevo->next = NULL;
	if(front == NULL){
		front = nuevo;
	}
	else{
		end->next = nuevo;
	}
	end = nuevo;
	quan++;
}

void Tail::advance(Node *&front,Node *&end){
	cout<<" the person \""<<front->im.get_name()<<"\" left the tail. "<<endl;
	Node *aux = front;
	if(front == end){
		front = NULL;
		end = NULL;
	}
	else{
		front = front->next;
	}
	delete aux;
	quan--;
}

void Tail::show(Node *front){
	int x = 1;
	while(front != NULL){
		cout<<x<<". Registry: \n";
		front->im.show_data();
		front = front->next;
		x++;
	}
}

void Tail::modificate(Node *front){
	cout<<" Enter position: ";cin>>pos;
	int con=1;
	while(front != NULL){
		if(con == pos){
			front->im.enter_data();
		}
		front = front->next;
		con++;
	}
}

36 --------------->>> CLASS AND OBJECTS :: CLASES Y OBJETOS :

EJEMPLO 1:
 
#include<iostream>
#include<conio.h>
using namespace std;

class Persona{
	private:                    //ATRIBUTOS ENCAPSULADOS.
		int age;
		string name;
	public:
		Persona(int,string);     //CONSTRUCTOR.
		void sleep();            //METODOS.
		void walk();
};

Persona::Persona(int age_send,string name_send){
	age = age_send;
	name = name_send;
}

void Persona::sleep(){
	cout<<"\nmy name is "<<name<<" and i am sleeping.\n\n";
}

void Persona::walk(){
	cout<<name<<" is walking and he is "<<age<<" year old.\n\n";
}

int main(){

	Persona p_1(19,"alexander");     //CREACION DEL OBJETO (VERSION 1).
	p_1.sleep();
	p_1.walk();
	
	Persona p_2 = Persona(27,"luis");    //CREACION DEL OBJETO (VERSION 2).
	p_2.sleep();
	p_2.walk();
		
	getch();
	return 0;
}

-- SI NO ESTAS EN DEVC++ USAR "#include<string>"  PARA PODER USAR LA VARIABLE CADENA "string".

EJEMPLO 2:    //OTRA FORMA DE ESTABLECER UNA CLASE.

#include<iostream>
#include<conio.h>
using namespace std;

class Rectangulo{
	private:
		int largo;
		int ancho;
	public:
		Rectangulo(int dato_1,int dato_2){
			largo = dato_1;
			ancho = dato_2;
		}
		void perimetro(){
			cout<<"\nTHE RECTANGLE PERIMETER IS : "<<2*(largo+ancho)<<endl;
		}
		void area();
};

void Rectangulo::area(){
	cout<<"\nTHE RECTANGLE AREA IS : "<<ancho*largo<<endl;
}

int main(){

	Rectangulo figura(3,2);
	figura.area();
	figura.perimetro();
	
	getch();
	return 0;
}

EJEMPLO 3 :  SOBRECARGA DE CONSTRUCTORES

#include<iostream>
#include<conio.h>
using namespace std;

class Fecha{
	private:
		int day,month,year;
	public:
		Fecha(int,int,int);
		Fecha(long);
		void show_date();
};

Fecha::Fecha(int d,int m,int y){        //CONSTRUCTOR 1.
	day = d;
	month = m;
	year = y;
}

Fecha::Fecha(long dato){               //CONSTRUCTOR 2.
	year = int(dato/10000);
	month = int((dato-year*10000)/100);
	day = int(dato -year*10000 -month*100);
}

void Fecha::show_date(){
	cout<<"show date: "<<day<<"/"<<month<<"/"<<year<<endl;
}

int main(){
	
	Fecha dt(9,3,2020);
	dt.show_date();
	
	Fecha dt_2 = Fecha(20200310);
	dt_2.show_date();
	
	getch();
	return 0;
}

EJEMPLO 4 : 

#include<iostream>
#include<conio.h>
using namespace std;

class Time{
	private:
		int hours,minuts,seconds;
	public:
		Time(int,int,int);
		Time(long);
		void show_time();
};

Time::Time(int h,int m,int s){   //CONSTRUCTOR 1.
	hours = h;
	minuts = m;
	seconds = s;
}

Time::Time(long full){		//CONSTRUCTOR 2.
	hours = full/3600;
	full %= 3600;
	minuts = full/60;
	seconds = full%60;
}

void Time::show_time(){
	cout<<" ITS: "<<hours<<":"<<minuts<<":"<<seconds<<" O CLOCK"<<endl;
	cout<<" TOTAL SECONDS: "<<(hours*3600 + minuts*60 + seconds)<<endl;
}

int main(){
	
	Time saber(5,33,17);
	saber.show_time();
	
	Time saber_2(3661);
	saber_2.show_time();
	
	getch();
	return 0;
}

EJEMPLO 5 :    		//DESTRUCTOR Y METER DATOS SIN ENVIAR.

#include<iostream>
#include<conio.h>
using namespace std;

class Perro{
	private:
		string name,raza;
	public:
		Perro();
		~Perro();   //destructor.     //PARA SACARLO POR TECLADO ES " Alt + 126 ".
		void datos();
		void jugar();
};

Perro::Perro(){   //funcion constructora, como la funcion main.
	cout<<" name: ";cin>>name;
	cout<<"raza: ";cin>>raza;
}

Perro::~Perro(){  //DESTRUCTOR BACIO, SIEMPRE ASI SI Q SI XD.
}

void Perro::datos(){
	cout<<" name: "<<name<<"-> raza: "<<raza<<endl;
}
void Perro::jugar(){
	cout<<" "<<name<<" esta jugando en el parque.";
}

int main(){
	
	Perro pr;
	pr.datos();
	pr.jugar();
	
	getch();
	return 0;
}

EJEMPLO 6 :   METODOS CONSTRUCTORES GET & SET :

#include<iostream>
#include<conio.h>
using namespace std;

class Nota{
	private:
		int promedio,unidad;
	public:
		Nota();
		void setNota_promedio(int );
		void setNota_unidad(int );
		int getNota_promedio();
		int getNota_unidad();
};

Nota::Nota(){
}

void Nota::setNota_promedio(int a){
	promedio = a;
}

void Nota::setNota_unidad(int b){
	unidad = b;
}

int Nota::getNota_promedio(){
	return promedio;
}

int Nota::getNota_unidad(){
	return unidad;
}

int main(){
	
	Nota alum1;
	
	alum1.setNota_promedio(19);
	alum1.setNota_unidad(3);
	
	cout<<alum1.getNota_promedio()<<endl;
	cout<<alum1.getNota_unidad()<<endl;
	
	getch();
	return 0;
}

EJEMPLO 7 : HERENCIA : 

#include<iostream>
#include<conio.h>
using namespace std;

class Gente{            //CLASE PADRE.
	private:
		string name;
		int age;
	public:
		Gente(string ,int );
		void show();
};

Gente::Gente(string n,int a){
	name = n;
	age = a;
}

void Gente::show(){
	cout<<" your name is: "<<name<<endl;
	cout<<" your age is: "<<age<<endl;
}

class Alumno : public Gente{         //ALUMNO ES HIJA DE GENTE Y PONEMOS PUBLIC PARA QUE TODO LO QUE VA A HEREDAR SEA LO PUBLICO.
	private:
		long codigo;
		float nota_f;
	public:
		Alumno(string,int,long,float);      //PARAMETROS PARA LA CLASE PADRE Y LA DE ALUMNO.
		void show_alumno();
};

Alumno::Alumno(string n,int a,long c,float nota):Gente(n,a){         //COLOCAMOS TODOS LOS PARAMETROS Y ":" CLASE PADRE ENVIANDO SUS PARAMETROS DE SU CONTRUCTOR.
	codigo = c;                                        //Y SOLO ASIGNAMOS LOS VALORES A LOS ATRIBUTOS DE ESTA CLASE.
	nota_f = nota;
}

void Alumno::show_alumno(){
	show();                     // LLAMA A LA FUNCION SHOW() DE GENTE QUE ES DE SU PADRE.
	cout<<" code: "<<codigo<<endl;
	cout<<" average: "<<nota_f<<endl;	
}

int main(){
	Alumno yo("alexander",19,15157334,19.6);      //CREAMOS UN OBJETO PERO CON LA CLASE HIJA ALUMNO.
	yo.show_alumno();
		
	getch();
	return 0;
}

EJEMPLO 8 : JERARAQUIA - HERENCIA :

#include<iostream>
#include<conio.h>
using namespace std;

class Gente{
	private:
		string name;
		int age;
	public:
		Gente(string ,int );
		void show();
};

Gente::Gente(string n,int a){
	name = n;
	age = a;
}

void Gente::show(){
	cout<<" your name is: "<<name<<endl;
	cout<<" your age is: "<<age<<endl;
}

class Empleado: public Gente{
	private:
		string job;
	public:
		Empleado(string,int,string);
		void show_empleado();
};

Empleado::Empleado(string n,int a,string j):Gente(n,a){
	job = j;
}

void Empleado::show_empleado(){
	show();
	cout<<" job: "<<job<<endl;
}

class Alumno : public Gente{
	private:
		long codigo;
		float nota_f;
	public:
		Alumno(string,int,long,float);
		void show_alumno();
};

Alumno::Alumno(string n,int a,long c,float nota):Gente(n,a){
	codigo = c;
	nota_f = nota;
}

void Alumno::show_alumno(){
	show();
	cout<<" code: "<<codigo<<endl;
	cout<<" average: "<<nota_f<<endl;	
}

class Universitario : public Alumno{
	private:
		string carrera;
	public:
		Universitario(string,int,long,float,string);     //SIEMPRE RESPETANDO LOS ANTERIORES ATRIBUTOS DEL PADRE Y ABUELO.(JERARQUIA)
		void show_universitario();
};

Universitario::Universitario(string n,int a,long c,float nota,string car):Alumno(n,a,c,nota){      //SE ENVIA EL CONTRUCTOR DE ALUMNO Y SUS PARAMETROS.
	carrera = car;
}

void Universitario::show_universitario(){
	show_alumno();
	cout<<" career :"<<carrera<<endl;
}

int main(){
	Universitario yo("alexander",19,15157334,19.6,"ing.sistemas");    //JERARQUIA.
	yo.show_universitario();
	
	cout<<" ---------------------\n\n";
	
	Empleado alex = Empleado("yorishi",150,"demon slayer");          //OTRA FORMA DE CREAR UN OBJETO.
	alex.show_empleado();
	
	getch();
	return 0;
}

EJEMPLO 9: POLIMORFISMO :

//PARA QUE UNA FUNCION DE PADRE PUEDA TENER POLIMORFISMO USAREMOS "VIRTUAL" AL PRINCIO DE LA FUNCION EJEMPLO: "virtual void show();"

#include<iostream>
#include<conio.h>
using namespace std;

class Ser{
	private:
		string especie;
	public:
		Ser(string);
		virtual void show();         //PARA PODER USAR EL POLIMORFISMO(USAR: "VIRTUAL").
		string get_especies();
};

class Perro : public Ser{
	private:
		int age;
	public:
		Perro(string, int);
		void show();
};

class Persona : public Ser{
	private:
		string sexo;
		int edad;
	public:
		Persona(string,string,int);
		void show();
};

class Ave : public Ser{
	private:
		bool can_fly;
	public:
		Ave(string,bool);
		void show();
};

Ser::Ser(string n){
	especie = n;
}

void Ser::show(){
	cout<<" especies: "<<especie<<endl;
}

string Ser::get_especies(){
	return especie;
}

Perro::Perro(string n,int a):Ser(n){
	age = a;
}

void Perro::show(){
	Ser::show();
	cout<<" age: "<<age<<endl;
}

Persona::Persona(string n,string s,int e):Ser(n){
	sexo = s;
	edad = e;
}

void Persona::show(){
	Ser::show();
	cout<<" sex: "<<sexo<<endl;
	cout<<" age: "<<edad<<endl;
}

Ave::Ave(string n,bool f):Ser(n){
	can_fly = f;
}

void Ave::show(){
	Ser::show();
	if (can_fly){
		cout<<" fly: YES"<<endl;
	}
	else{
		cout<<" fly: NO"<<endl;
	}
}

int main(){
	
	Ser *vec[3];   //CREAMOS UN PUNTERO DE TIPO CLASE SER.
	
	vec[0] = new Perro("perro",8);	       //CREAMOS OBJETOS CON SUS RESPECTIVAS CLASES SEGUN SUS PARAMETROS O INSTANCIA DE CLASE.
	vec[1] = new Persona("humano","masculino",19);
	vec[2] = new Ave("Cuervo",true);
	
	for(int i=0;i<3;i++){
		cout<<"-------"<<vec[i]->get_especies()<<"-------\n";    //IMPRIME LAS RAYAS Y EN MEDIO LA ESPECIE.
		vec[i]->show();    // "->" ES COMO USAR "." PERO EN PUNTEROS. MUESTRA LA FUNCION RESPECTIVA SEGUN SU CLASE("SHOW()").
	}

	
	getch();
	return 0;
}

EJEMPLO 10 : POLIMORFISMO : PROTECTED :

//PROTECTED : ES COMO PRIVADO PERO COMPARTIDO PARA LAS CLASES HIJAS DE ESTA, O SEA SE PUEDE LLAMAR DESDE CUALQUIER CLASE HIJA POR HERENCIA.

#include<iostream>
#include<conio.h>
#include<string.h>
using namespace std;

class Animal{
	protected:        // USO DEL PROTECTED.
		string name;
	public:
		Animal(string);
		virtual void eat();
		
};

class Humano : public Animal{
	private:
		int age;
	public:
		Humano(string,int );
		void eat();
};

class Perro : public Animal{
	private:
		int age_c;
	public:
		Perro(string ,int );
};

Animal::Animal(string n){
	name = n;
}

void Animal::eat(){
	cout<<" the animal "<<name<<" is eating."<<endl;
}

Humano::Humano(string n,int a):Animal(n){
	age = a;
}
void Humano::eat(){
	cout<<" the human "<<name<<" is eating."<<endl;
}

Perro::Perro(string n,int a):Animal(n){
	age_c = a;
}

int main(){
	Animal *array[2];
	
	array[0] = new Humano("aldo",24);
	array[1] = new Perro("fido",8);
	
	array[0]->eat();       //SALIDA : THE HUMAN ALDO IS EATING.
	array[1]->eat();       //SALIDA : THE ANIMAL FIDO IS EATING.
	
	getch();
	return 0;
}

37 -------------------->>> ALGEBRA DE BOOL:

-- USO DE " ^ " : XOR binario.
 	-DEVUELVE TRUE O FALSE SEGUN LOS NUMEROS ENVIADOS, TRUE SI SON DIFERENTES, FALSE SI SON IGUALES.

#include<iostream>
#include<conio.h>
using namespace std;

int uso_de_v_invertida(int,int);
int uso_de_v_invertida_2(int,int);

int main(){
	cout<<uso_de_v_invertida(-3,-3)<<endl;   //SALIDA : 0  OR false.
	cout<<uso_de_v_invertida(2,3)<<endl;    //SALIDA : 1   OR true.
	
	cout<<uso_de_v_invertida_2(-3,-3)<<endl;   //SALIDA : 1 OR true.
	cout<<uso_de_v_invertida_2(2,3)<<endl;    //SALIDA : 0   OR false.

	getch();
	return 0;
}

int uso_de_v_invertida(int a,int b){   		//NORMAL.
	return (a ^ b);
}
int uso_de_v_invertida_2(int a,int b){     	//PARA VER SI SON IGUALES CON NEGACION.
	return !(a ^ b);
}

--USO DE " - " : PARA VER SI SON IGUALES O DIFERENTES :

#include<iostream>
#include<conio.h>
using namespace std;

int uso_de_MENOS(int,int);

int main(){
	cout<<uso_de_MENOS(13,-3)<<endl;  //SALIDA : 0  OR FALSE.
	cout<<uso_de_MENOS(2,2)<<endl;     //SALIDA : 1  OR TRUE.
	
	
	getch();
	return 0;
}

int uso_de_MENOS(int a,int b){
	return !(a - b);
}

38 -------------------->>>>  IGUALDAD ENTRE PUNTERO Y REFERENCIA : COMPARACION : NEW & DELETE  WITH CLASS AND STRUCT :

MEJOR CONCEPTO : CUANDO SE CREA POR PARAMATROS "(INT &) O (STRUCT &) O (CLASS &)" SE SABE QUE SE PODRA JUGAR CON EL VALOR DE LA MEMORIA EN SI O SEA QUE CAMBIARA SI ESQUE LE DAMOS UN VALOR EN LA FUNCION.
ejemplo 0:

struct hola{
	hola *next;
};

void change(hola *&dato){
	hola *nuevo = new hola();
	dato = nuevo;  //LA MEMORIA SE CAMBIO EN TODO EL PROGRAMA.
}

/* -DIFERENTE A : */
void change(hola *dato){
	hola *nuevo = new hola();
	dato = nuevo;  //LA MEMORIA SE CAMBIO SOLO EN ESTA INSTANCIA.
}

--> OTRO DATO IMPORTANTE :

int dato = 3;     //modo simplificado.
cout<<&dato<<endl; //0x9a1520

//ES IGUAL A:

int &dato = *new int[1];   //modo original, es lo que realmente pasa.
dato = 3;
cout<<&dato<<endl; //0x9a1520

////RECORDAR QUE POR REFERENCIA SOLO SE ALACENA UN VALOR, SI QUEREMOS UN ARRAY USAREMOS "*" PUNTEROS.

--EJEMPLO 1: " CON * " PUNTERO.

#include<iostream>
#include<conio.h>
using namespace std;

void uso_de_v_invertida(int *);

int main(){
	int num=3;
	cout<<" var num antes: "<<num<<endl;
	
	uso_de_v_invertida(&num);

	cout<<" var num despues: "<<num<<endl;
	cout<<" var num despues: "<<num<<endl;
	
	getch();
	return 0;
}

void uso_de_v_invertida(int *a){
	*a=15;
}

-- EJEMPLO 2: " CON & " REFERENCIA.

#include<iostream>
#include<conio.h>
using namespace std;

void uso_de_v_invertida(int &);

int main(){
	int num=3;
	cout<<" var num antes: "<<num<<endl;
	
	uso_de_v_invertida(num);

	cout<<" var num despues: "<<num<<endl;
	cout<<" var num despues: "<<num<<endl;
	
	getch();
	return 0;
}

void uso_de_v_invertida(int &a){
	a=15;
}

--- EJEMPLO 1 Y EJEMPLO 2 SON IGUALES, CON DIFERENCIA QUE UNO ES SOLO PARA ALGO Y EL OTRO PARA MAS COSAS O EN OTRAS PALABRAS VALORES UNICOS Y MATRICES O VECTORES.

--- CAMBIO DE VARIABLES CON NEW & DELETE :

#include<iostream>
#include<conio.h>
#include<stdlib.h>
#include<string.h>
using namespace std;

class Intencidad{
	private:
		int power;
	public:
		Intencidad(){
			power = 10;
		}
		void show(){
			cout<<" poder de intencidad: "<<power<<endl;
		}
};

struct Nombre{
	char name[20];
};

int main(){
	Intencidad *puntero = new Intencidad;
	Nombre *puntero_2 = new Nombre;
	
	puntero->show();
	
	strcpy(puntero_2->name,"alexander");
	cout<<" the name is: "<<puntero_2->name<<endl;
	
	cout<<"\n---CAMBIO DE PUNTERO A REFRENCIA---\n"<<endl;
	
	Intencidad &dato = *puntero;
	Nombre &dato_2 = *puntero_2;
	
	dato.show();
	
	strcpy(dato_2.name,"OKINIMESUMA");
	cout<<"the name 2 is: "<<dato_2.name<<endl;
	
	if(puntero) {   //si el puntero no es 0 o NULL o sea se mide en true o false.
		cout<<" Deleting puntero."<<endl;
		delete puntero;   //ASI LIBERARA LA MEMORIA DE PUNTEROS Y DE SI MISMA.
	}
	if(puntero_2) {
		cout<<" Deleting puntero_2."<<endl;
		delete puntero_2; 
	}
	//PARA ELIMINAR A UNA REFRENCIA USAMOS :  delete &refrencia_nombre;
	
	getch();
	return 0;
}

//SALIDA:

 poder de intencidad: 10
 the name is: alexander

---CAMBIO DE PUNTERO A REFRENCIA---

 poder de intencidad: 10
the name 2 is: OKINIMESUMA
 Deleting puntero.
 Deleting puntero_2.

39--------------------->>>> ARCHIVOS C++ : FILE C++ : FILES C++ : files : data base : database : 

#include<iostream>
#include<conio.h>
#include<fstream>     // LIBRERIA PARA USAR LOS ARCHIVOS.
#include<stdlib.h>     // PARA PODER USAR EL EXIT(1)
using namespace std;

void create_file();
void add_text();
void read_file();

int main(){
	create_file();
	add_text();
	read_file();
	
	getch();
	return 0;
}

void create_file(){
	ofstream archivo;         // OFSTREAM PARA CREAR Y INGRESAR TEXTO.
	string nombre;
	
	cout<<" Enter file name: ";
	getline(cin,nombre);
	
	archivo.open(nombre.c_str(), ios::out);        // PRIMERA FORMA DE INGRESAR EL NOMBRE DEL DOCUMENTO CON LA FUNCION .C_STR()  Y ARCHIVO EN MODO CREACION (OUT).
	
	if(archivo.fail()){                            // EN CASO QUE NO SE ENCUENTRE UN ARCHIVO USAMOS LA FUNCION .FAIL() PARA VERIFICAR.
		cout<<" Error. cant create the file."<<endl;
		exit(1);
	}
	else{
		archivo<<" HOLA ESTE ES EL ARCHIVO"<<endl;
		archivo<<" ahora en ingles, hello this is the file."<<endl;
		
		archivo.close();        // CIERRA EL ARCHIVO PARA NO EXCEDER EL USO DE MEMORIA.
	}
}
void add_text(){
	ofstream file;
	string comentarios;
	char band='Y';
	
	file.open("alexander.txt", ios::app);             // SEGUNDA FORMA DE ENVIAR AL NOMBRE DEL ARCHIVO Y ABRIMOS ARCHIVO EN MODO AÑADIR (APP).
	
	if(file.fail()){
		cout<<" Error. cant add text to the file."<<endl;
		exit(1);
	}
	else{
		while(band =='Y' || band == 'y'){
			fflush(stdin);           	// LIMPIA LA MEMORIA DEL BUFFER PARA LA UTILIDAD DEL TECLADO.
			cout<<" Text: ";
			getline(cin, comentarios);
			
			file<<comentarios<<endl;        // PARECIDO A UN COUT PERO EN VEZ DE COUT EL NOMBRE DEL ARCHIVO Y ENVIAMOS EL MENSAJE COMO PARA IMPRIMIR POR CONSOLA.
			do{
				cout<<" Do you want continue? (y/n): ";
				cin>>band;
			}while(band != 'Y' && band != 'N'  && band != 'y' && band != 'n');
		}
		
		file.close();
	}
}
void read_file(){
	ifstream datos;        // IFSTREAM  PARA LEER ARCHIVOS.
	string info;
	
	datos.open("D:\\Alexander\\C++ ALEX\\c++ archivos\\alexander.txt", ios::in);     //TERCERA FORMA DE ENVIAR EL NOMBRE Y ABRIMS EL ARCHIVO EN MODO LECTURA (IN).
	
	if(datos.fail()){
		cout<<" Error. file didnt find."<<endl;
		exit(1);
	}
	else{
		while(!datos.eof()){    		//MIENTRAS QUE NO SEA EL FINAL
		   				// .EOF() SI ES EL FINAL ENTONCES RETORNA TRUE, CASO CONTRARIO FALSE.
		   getline(datos, info);           //EN VEZ DEL CIN PONEMOS LA VARIABLE DEL ARCHIVO COMO TIPO DE OBTENCION DE DATOS.
		   cout<<info<<endl;               //IMPRIMIMOS COMO SIEMPRE.
		}
		datos.close();
	}
}

///////// ARCHIVOS BINARIOS :: FILES BINARIES :: WB - AB - AB+ :: FILES C++ BINARIES ::

->/// 1 . CREACION DE UN ARCHIVO :: 

#include<iostream>
#include<conio.h>
using namespace std;
int main(){
	FILE *ptr_archivo;
	ptr_archivo = fopen("C:\\carpeta\\documento_alex.txt","wb");
	if(ptr_archivo == 0){
		cout<<"Error, no se pudo crear el archivo."<<endl;
		system("pause");
		exit(1);
	}
	else{
		cout<<"se pudo crear el archivo correctamente."<<endl;
		system("pause");
		fclose(ptr_archivo);
	}
	return 0;
}

-> /// 2 . AÑADIENDO DATOS BINARIOS AL ARCHIVO :: files :: write files ::

°°°fwrite(&persona, sizeof(DNI), 1, ptr_archivo);°°°

1. Como primer parámetro se coloca la dirección del registro que se va a grabar en el
archivo, en este caso de la variable varProducto.
2. En un segundo parámetro se debe especificar la cantidad de espacio en bytes que
ocupará en el archivo, se puede hacer de form explícita o de lo contrario con el
operador sizeof().
3. Para el tercer parametro se especifica el número de registros que se van a grabar en
el archivo, en este caso uno, pero se puede grabar un número mayor de registros a
la vez.
4. El último parámetro es para especificar la dirección en disc donde se almaceará los
registros, en este caso se usa el puntero a archivo ptrArchivo1

#include<iostream>
#include<conio.h>
using namespace std;

struct DNI{
	int number;
	char full_name[50];
	bool casado;
};

int main(){
	FILE *ptr_archivo;
	DNI persona;
	ptr_archivo = fopen("C:\\carpeta\\documento_alex.dat","ab");     //AHORA YA NO EN TXT SINO EN .DAT Y SEGUNDO PARAMETRO EN "AB", PARA AÑADIR EN BINARIO.
	if(ptr_archivo == 0){      //SI NO SE ENCUENTRA EL PUNTERO RESIVIRA UN NULO.
		cout<<"Error, no se pudo añadir elementos al archivo."<<endl;
		system("pause");
		exit(1);
	}
	else{
		cout<<"se pudo ingresar el archivo correctamente."<<endl;
		system("pause");
		system("cls");
		char var_married;
		cout<<" DNI \n\n";
		cout<<" enter name: ";
		gets(persona.full_name);
		cout<<" enter id: ";
		cin>>persona.number;
		fwrite(&persona, sizeof(DNI), 1, ptr_archivo);    // LA MAS IMPORTANTE PARA ESCRIBIR AL ARCHIVO.DAT.
		do{
		cout<<" Do you are married? (Y/N): ";
		cin>>var_married;
		var_married = toupper(var_married);
		}while(var_married != 'Y' && var_married != 'N');
		if(var_married=='Y'){
			persona.casado = true;
		}
		else{
			persona.casado = false;
		}
		fclose(ptr_archivo);
	}
	return 0;
}

-> /// 3 . LEER ARCHIVOS BINARIOS ::

°°°fread(&varProducto,sizeof(varProducto),1,ptrArchivo1);°°°

1. La función fread(), devuelve el número de registros que leyó del disco, por eso el ciclo
while se convierte en falso cuando fread() regresa 0 y esto indica que se llegó al final
del archivo

#include<iostream>
#include<conio.h>
using namespace std;

struct DNI{
	int number;
	char full_name[50];
	bool casado;
};

int main(){
	FILE *ptr_archivo;
	DNI persona;
	ptr_archivo = fopen("C:\\carpeta\\documento_alex.dat","ab+");    // AHORA EN IGUAL MODO QUE EL ANTERIOR PERO CON UN + O SEA "AB+" PARA MODO LECTURA.
	if(ptr_archivo == 0){
		cout<<"Error, no se pudo encontrar el archivo."<<endl;
		system("pause");
		exit(1);
	}
	else{
		cout<<"se pudo ingresar al archivo correctamente."<<endl;
		system("pause");
		system("cls");
		while(fread(&persona, sizeof(persona), 1, ptr_archivo) == 1){  	// IMPORTANTE.
			cout<<" DOCUMENTO NACIONAL DE IDENTIDAD\n\n";
			cout<<" Name: "<<persona.full_name<<endl;
			cout<<" Numero : "<<persona.number<<endl;
			if(persona.casado){
				cout<<" Casado: SI"<<endl;	
			}
			else{
				cout<<" Casado: NO"<<endl;
			}
		}
		fclose(ptr_archivo);
	}
	return 0;
}

-> /// 4 . BUSCAR Y LEER ARCHIVOS BINARIOS ::

void posicion_all(){
	int pos;
	FILE *archivo;
	Almacen depo;
	
	archivo = fopen("D:\\alexander\\c++ alex\\punteros\\ejercicio_01\\almacen.dat","ab+");
	if (archivo==0){
		cout<<" Error, doesnt login in the file."<<endl;
		system("pause");
		exit(1);
	}
	else{
		cout<<"\n Enter Register number: ";cin>>pos;     
		//IMPORTANTE    
		fseek(archivo, (long)(pos-1) * sizeof(depo), 0);   // LE RESTO -1 EN POS PORQUE NOSOTROS ENVIAMOS 1,2,3.. NORMALMENTE PERO EN POSICIONES DE MEMORIA YA SABEN QUE ES 0,1,2... .
		fread(&depo, sizeof(depo), 1, archivo);
		depo.show();
		fclose(archivo);
	}
}

// NUEVO USO CON EL FSEEK() :

- VA A LA POSICION DE LECTURA DEL ARCHIVO BINARIO EJEMPLO . :

void posicion_all(){
	int pos;
	FILE *archivo;
	Almacen depo;
	
	archivo = fopen("D:\\alexander\\c++ alex\\punteros\\ejercicio_01\\almacen.dat","ab+");
	if (!archivo){
		cout<<" Error, doesnt login in the file."<<endl;
		system("pause");
		exit(1);
	}
	else{
		system("cls");
		cout<<"\n Enter Registry number: ";cin>>pos;
		fseek(archivo, (long)(pos-1) * sizeof(depo), 0);
		fread(&depo, sizeof(depo), 1, archivo);
		depo.show();
		system("pause");
		system("cls");
		fclose(archivo);
	}
}

IMPORTANTE :

fseek(archivo, (long)(posicion-1) * sizeof(Almacen o depo), 0);

Donde los parámetros son:
 El primer parámetros es el apuntador al archivo en disco
 El segundo parámetro es el BYTE donde se quiere que empiece la lectura o grabación al archivo en disco. Este BYTE debe ser de tipo LONG, se usa el operador sizeof o tamaño de registro para calcular la pocisión exacta.
 El tercer parámetro es a partir de donde se quiere posicionar el apuntador interno del archivo, los valores pueden ser:
0 ---> SEEK_SET principio del archivo. 
1 ---> SEEK_CUR posición actual.
2 ---> SEEK_END fin del archivo.

-> // EJEMPLO DE LOS 3 FORMAS O ALGO ASI + BONUS : : 

void modificar(){
	FILE *file,*file_2;
	Almacen dato,dato_2;
	int modi,con_x=0;
	file = fopen("D:\\alexander\\c++ alex\\punteros\\ejercicio_01\\almacen.dat","ab+");     //MODO AÑADIR Y LEER.
	file_2 = fopen("D:\\alexander\\c++ alex\\punteros\\ejercicio_01\\almacen_2.dat","wb+");  //MODO AÑADIR, LEER ,Y CREAR  O REMPLAZA SI YA EXISTE.

	if(!file){                     // SI NO EXISTE EL CONTENIDO DEL PUNTERO NO ABRA MEMORIA Y SERIA "0" O FALSE. Y SE PONE EL "!" PARA CONTRADECIR ESO Y DENTRAR AL IF.
		cout<<" Error, file didnt find."<<endl;
		system("pause");
		exit(1);
	}
	else{
		system("cls");
		cout<<"\n Enter Registry number: ";cin>>modi;
		
		fseek(file,(long)(modi-1)*sizeof(dato),0);
		fread(&dato, sizeof(dato), 1, file);
		dato.show();
		dato_2.enter();
		
		fseek(file,(long)(0)*sizeof(dato),0);
		while(fread(&dato,sizeof(dato),1,file)){
			if(modi-1 == con_x){
				fwrite(&dato_2, sizeof(Almacen),1,file_2);
			}
			else{
				fwrite(&dato, sizeof(Almacen),1,file_2);
			}
			con_x++;
		}
		fclose(file);
		
		file = fopen("D:\\alexander\\c++ alex\\punteros\\ejercicio_01\\almacen.dat","wb+");   // MODO DE CREAR, LEER, AÑADIR O REMPLAZA SI YA EXISTE.
		fseek(file_2,(long)(0)*sizeof(Almacen),0);
		while(fread(&dato,sizeof(Almacen),1,file_2)){
			fwrite(&dato,sizeof(Almacen),1,file);
		}
		system("pause");
		system("cls");
		fclose(file_2);
		remove("almacen_2.dat");     // ELIMINA EL ARCHIVO DE LA MEMORIA DEL DISCO.
		fclose(file);
	}
}

->PARA INGRESAR VARIOS REGISTROS :

#include<iostream>
#include "menu.h" //DONDE SE ENCUENTRAN LA CLASS YO Y DEMAS FUNCIONES.
using namespace std;
int main(){
	FILE *arg;
	Yo some[2];
	int con=2;
	arg = fopen("D:\\yatusabe.dat","wb");
	
	for(int i=0;i<con;i++){
		some[i].enter();
	}
	
	fwrite(some,sizeof(some),con,arg);   //ALMACENO 2 REGISTROS, Y EN EL PRIMER PARAMETRO SE ENVIO EL PRIMER ELEMENTO O EL INICIO DE MEMORIA DE ESE ARRAY.
	fclose(arg);
	
	for(int i=0;i<con;i++){
		some[i].show();
	}	
	
	return 0;
}

-> // ARCHIVOS CON 15 NOMBRES Y ENTRAD DE DATOS, CLASS ETC : //

#include<iostream>
#include<string.h>
using namespace std;

void entry(char *cade,int quan){
	fflush(stdin);
	cin.getline(cade,quan,'\n');
	fflush(stdin);
}

struct Directory{
	char name_dir[15][40];
	int quan = 0;
	void enter_name();
	char *get_name(){
		return name_dir[quan-1];
	}
	char *get_name_pos(){
		int pos;
		cout<<" Enter position: ";cin>>pos;
		return name_dir[pos-1];
	}
	int get_quan(){
		return quan;
	}
};

void Directory::enter_name(){
	cout<<" Enter name Directory (name_directory.dat): ";entry(name_dir[quan],40);
	quan++;
}

class Person{
	private:
		char name[30];
		int age;
		int dni;
	public:
		void enter();
		void show();
};

void Person::enter(){
	cout<<" Enter name: ";entry(name,30);
	cout<<" Enter dni: ";cin>>dni;
	cout<<" Enter age: ";cin>>age;
}

void Person::show(){
	cout<<" name: "<<name<<endl;
	cout<<" dni: "<<dni<<endl;
	cout<<" age: "<<age<<endl;
}

class Files{
	public:
		char origin[60]="D:\\Alexander\\c++\\", auxiliar[60]="D:\\Alexander\\c++\\";
		FILE *file;
		Directory dir;
		Person person;
		void enter_data();
		void show_data();
		void create_data();
		void clean_dir(char *);
};

void Files::clean_dir(char *cade){
	for(int i=0; i<20;i++){
		cade[i] = NULL;
	}
	strcpy(cade,auxiliar);
}

void Files::create_data(){
	dir.enter_name();
	strcat(origin,dir.get_name());
	file = fopen(origin,"wb");
	if(!file && dir.quan > 14){
		cout<<"\n Error, Program.\n"<<endl;
		system("pause");
		exit(1);
	}
	else{
		fclose(file);
	}
	cout<<" Created: "<<origin<<endl;
	clean_dir(origin);
}

void Files::enter_data(){
	strcat(origin,dir.get_name_pos());
	cout<<" Current : "<<origin<<endl;
	file = fopen(origin,"ab");
	if(!file){
		cout<<"\n Error, Program.\n"<<endl;
		system("pause");
		exit(1);
	}
	else{
		person.enter();
		fwrite(&person,sizeof(person),1,file);
		fclose(file);
	}
	clean_dir(origin);
}

void Files::show_data(){
	strcat(origin,dir.get_name_pos());
	cout<<" Current : "<<origin<<endl;
	file = fopen(origin,"rb");
	if(!file){
		cout<<"\n Error, Program.\n"<<endl;
		system("pause");
		exit(1);
	}
	else{
		fread(&person,sizeof(person),1,file);
		person.show();
		fclose(file);
	}
	clean_dir(origin);
}

void Menu(){
	Files algo;
	int op;
	do{
		cout<<"\t Registry:\n 1) new\n 2) enter\n 3) show\n 4) exit\n option:  ";cin>>op;
		switch(op){
			case 1:
				algo.create_data();break;
			case 2:
				algo.enter_data();break;
			case 3:
				algo.show_data();break;
			case 4:break;
			default: cout<<"\n That Option Doesnt Exist.\n\n";
		}
	}while(op != 4);
}

int main(){
	
	Menu();
	
	return 0;
}

40 --------------------->>> SIZEOF (VALOR) : FOREACH NORMAL :

La función recibe como único parámetro o el nombre de una variable, o el nombre de un tipo de datos,
y devuelve su tamaño en bytes. De esta forma, sizeof(int) devuelve el número de bytes que se utilizan
para almacenar un entero. La función se puede utilizar también con tipos de datos estructurados o uniones tal 


//PARA UN INT LO DIVIDIREMOS ENTRE CUATRO(/4).
//PARA UN CHAR LE RESTAREMOS UNO(-1).

int numbers[]={1,2,3,45,81};
char string[]="alexander";

cout<<sizeof(numbers)/4<<endl;   //5 (porque sale 20/4 , un entero o int vale 4 bytes).
cout<<sizeof(string)-1<<endl;    //9 (sale 10-1,un char vale 1 byte pero por alguna razon se le suma algo asi que por eso le resto 1).

for(int i=0; i<sizeof(numbers)/4; i++{
	cout<<numbers[i]<<endl;
}

//RECORRERA TODO EL ARREGLO : 1,2 ....45,81

for(int i=0; i<sizeof(string)-1; i++{
	cout<<string[i]<<endl;
}

//a,l,e,.....,d,e,r

41 ------------------->>>  FUNCION LAMBDA EN C++ : #DEFINE : DEFINE :

#define potencia(x) x*x      

cout<<potencia(5)<<endl;     //25


42 ------------------>>> LISTAS C++ : LIST C++ : 

---EJEMPLO 1 : 

#include<iostream>
using namespace std;

struct Node{
	int number;
	Node *next;
};

int get_num(){
	int dato;
	cout<<" Enter number: ";cin>>dato;
	return dato;
}

bool find_list(Node *,int);
void show_list(Node *);
void add_list(Node *&,int );
void delete_list(Node *&,int ); 	//FORM 1
void delete_element(Node *&,int );	//FORM 2
void clear_list(Node *&);

int main(){
	Node *lista = NULL;
	int op;
	do{
		cout<<" \tLIST:\n 1)add\n 2)show\n 3)delete form 1\n 4)delete form 2\n 5)find number\n 6)clear list\n option: ";cin>>op;
		switch(op){
			case 1:add_list(lista,get_num());break;
			case 2:show_list(lista);break;
			case 3:delete_element(lista,get_num());break;
			case 4:delete_list(lista,get_num());break;
			case 5:find_list(lista,get_num());break;
			case 6:clear_list(lista);break;
		}
	}while(1);
	
	return 0;
}

void add_list(Node *&lista,int val){
	Node *new_node = new Node();
	new_node->number = val;
	new_node->next = NULL;
	
	Node *aux1 = lista;
	Node *aux2;
	
	while((aux1!=NULL) && (aux1->number<val)){
		aux2 = aux1;
		aux1 = aux1->next;
	}
	
	if(aux1==lista){
		lista = new_node;
	}
	else{
		aux2->next = new_node;
	}
	new_node->next = aux1;
	cout<<" "<<new_node->number<<" add to list."<<endl;
}

void show_list(Node *lista){
	while(lista!=NULL){
		cout<<" -> "<<lista->number<<endl;
		lista = lista->next;
	}
}

bool find_list(Node *lista,int val){
	while(lista!=NULL){
		if(val == lista->number){
			cout<<" Si se encuentra el numero."<<endl;
			return true;
		}
		lista = lista->next;
	}
	cout<<" No se encontro el numero."<<endl;
	return false;
}

void delete_list(Node *&lista,int val){
	Node *aux1 = lista;
	Node *aux2=NULL;
	bool band = false;
	while(aux1 != NULL){
		if(aux1->number != val){
			band = true;
			add_list(aux2,aux1->number);
		}
		aux1 = aux1->next;
	}
	if(!band){
		cout<<" No se encuantra ese numero."<<endl;
	}
	lista = aux2;
}

void delete_element(Node *&lista,int val){
	if(lista!=NULL){
		Node *borrar_dato = lista;
		Node *anterior = NULL;
		while((borrar_dato != NULL) && (borrar_dato->number != val)){
			anterior = borrar_dato;
			borrar_dato = borrar_dato->next;
		}
	
		if(borrar_dato == NULL){
			cout<<" No existe ese elemento."<<endl;
		}
		else if(anterior == NULL){
			lista = borrar_dato->next;
			delete borrar_dato;
		}
		else{
			anterior->next = borrar_dato->next;
			delete borrar_dato;
		}	
	}
}

void clear_list(Node *&lista){
	Node *aux = NULL;
	while(lista!=NULL){
		aux = lista->next;
		delete lista;
		lista = aux;
	}
}

---EJEMPLO 2 :

#include<iostream>
using namespace std;

struct Node{
	int number;
	Node *next;
};

int get_num(){
	int num;
	cout<<" Enter number: ";cin>>num;
	return num;
}

void add_element(Node *&list,int val);
void show_elements(Node *list);
void delete_element(Node *&list,int val);
int calculate_less(Node *list);
int calculate_major(Node *list);
void calculate_average(Node *list);


int main(){
	Node *list = NULL;
	char con;
	do{
		add_element(list,get_num());
		cout<<" do you want to continue? y/n: ";cin>>con;
		con = toupper(con);
	}while(con == 'Y');
	
	show_elements(list);
	
	cout<<"\nless: "<<calculate_less(list)<<endl;
	
	cout<<"\nmajor: "<<calculate_major(list)<<endl;	
	calculate_average(list);
	
	return 0;
}

void calculate_average(Node *list){
	int cont=0,sum=0;
	while(list != NULL){
		sum += list->number;
		cont++;
		list = list->next;
	}
	cout<<" all sum: "<<sum<<endl;
	cout<<" average: "<<sum/cont<<endl;
}

void add_element(Node *&list,int val){
	Node *new_node = new Node();
	new_node->number = val;
	new_node->next = NULL;
	
	Node *aux1 = list;
	Node *aux2 = NULL;

	if(list == NULL){
		list = new_node;
	}
	else{
		while(aux1 != NULL){
			aux2 = aux1;
			aux1 = aux1->next;
		}
		aux2->next = new_node;		
	}
	cout<<"\n Add number "<<new_node->number<<" to the list.\n"<<endl;
}

void show_elements(Node *list){
	while(list != NULL){
		cout<<" -> "<<list->number;
		list = list->next;
	}
}

void delete_element(Node *&list,int val){
	bool there = true;
	
	Node *aux1 = list;
	Node *aux2 = NULL;
		
	while(aux1 != NULL){
		if(aux1->number != val){
			add_element(aux2,aux1->number);
		}
		else{
			there = false;
		}
		aux1 = aux1->next;
	}
	
	if(there){
		cout<<" No existe ese numero."<<endl;
	}
	
	list = aux2;
}

int calculate_less(Node *list){
	int reply = 1000;	
	while(list != NULL){
		if(reply > list->number){
			reply = list->number;
		}
		list = list->next;
	}
	return reply;
}

int calculate_major(Node *list){
	int reply = 0;	
	while(list != NULL){
		if(reply < list->number){
			reply = list->number;
		}
		list = list->next;
	}
	return reply;	
}


EJEMPLO 3 ----- LIST WITH BINARY FILES :: LISTA CON ARCHIVOS BINARIOS ::

#include<iostream>
#include<stdio.h>
#include "People.h"
using namespace std;

struct Node {
	People* some;   // "People es una clase simple de registro de un nombre, con entrada, salida, get ,y set"
	Node* next;
};
void comprobate(Node*&);
void creat();
void add_element(People* people);
void refresh(Node*&);

void add(Node*&);
void add_refresh(Node*&,People* people);
void show(Node*);

int main() {
	Node* list = NULL;
	int op;
	comprobate(list);
	do {
		cout << "\n 1) add\n 2) show\n 3) exit\n option: "; cin >> op;
		switch (op)
		{
		case 1:
			add(list); break;
		case 2:
			show(list); break;
		case 3:
			break;
		default:
			cout << " error\n\n";
			break;
		}
		system("pause");
	} while (op != 3);
	return 0;
}

void add(Node*& list) {
	Node* aux = new Node;
	aux->some = new People;
	aux->some->enter_name();
	aux->next = NULL;
	Node* aux2 = list;
	if (list == NULL) {
		list = aux;
	}
	else {
		while (aux2->next != NULL) {
			aux2 = aux2->next;
		}
		aux2->next = aux;
	}
	add_element(aux->some);
}
void add_refresh(Node*& list, People* people) {
	Node* aux2 = list;
	Node* aux = new Node;
	aux->next = NULL;
	aux->some = new People;  //memoria a establecer, no perteneciente al DB.
	aux->some->set_name(people->get_name());
	if (list == NULL) {
		list = aux;
	}
	else {
		while (aux2->next != NULL) {
			aux2 = aux2->next;
		}
		aux2->next = aux;
	}
}
void show(Node* list) {
	Node* aux = list;
	while (aux != NULL) {
		aux->some->show_name();
		aux = aux->next;
	}
}

FILE* file;
errno_t error;
void comprobate(Node*& list) {
	error = fopen_s(&file, "D:\\lista.dat", "rb");
	if (error) {
		creat();
	}
	else {
		refresh(list);
	}
}
void creat() {
	error = fopen_s(&file, "D:\\lista.dat", "wb"); //si la funcion no responde, devuelve 1.
	if (error) {
		cout << " File Cant Created\n";
		exit(0);
	}
	else {
		cout << " File Created\n";
		fclose(file);
	}
}
void add_element(People* people) {
	error = fopen_s(&file, "D:\\lista.dat", "ab");
	if (error) {
		cout << " Element Cant Added\n";
		exit(0);
	}
	else {
		cout << " Element Added\n";
		fwrite(people, sizeof(People), 1, file);
		fclose(file);
	}
}
void refresh(Node*& list) {
	error = fopen_s(&file, "D:\\lista.dat", "rb");
	if (error) {
		cout << " Element Cant read\n";
		exit(0);
	}
	else {
		cout << " Elements read\n";
		Node* aux= new Node;
		People* people = new People;  //memoria dinamica temporal
		while (fread(people, sizeof(People), 1, file)) {
			add_refresh(list,people);
		}
		fclose(file);
	}
}

43 ------------------>> PRAGMA ONCE : IFNDEF : #PRAGMA ONCE : #IFNDEF #DEFINE #ENDIF : archivo .h :

----#ifndef ARCHIVO_H
/* Archivo alex.h */

#include<iostream>
#ifndef ALEX_H
#define ALEX_H

class yo{
	public:
		int edad;
}

/* puede ser una struct, funcion, dato global. */

#endif ALEX_H      /* otra opcion es " #endif " solo eso */

------#pragma once
/* Archivo alex.h */
#include<iostream>
#pragma once

class yo{
	public:
		int edad;
}

/* puede ser una struct, funcion, dato global. */

/*  EN CONCLUSION SON LO MISMO SOLO QUE EL PRAGMA ES MAS SIMPLE */

44 ---------------->>>> PUNTEROS EN FUNCIONES : *FUNCION() : FUNCION PUNTERO : FUCTION POINTER : PUNTERO FUNCION :

int *get_array(){  		//AL IGUAL QUE CREAR UNA VARIABLE SE AGREGA EL " * " PARA EL APUNTADOR.
	return array;		//ESTO DEVOLVERA LA PRIMERA POSICION O "DIRECCION" DE MEMORIA DEL ARRAY, CLASS, STRUCT ETCTCETCETC.
}

class Gato{
	public:
		int hijos;
		Gato *get_gato();
}

Gato*::get_Gato(){
	return this;   	    //RETORNA LA DIRECCION DE MEMORIA DE LA CLASE.
}

45 ---------------->>>> OPERADOR TERNARIO : " ?: " :

-EXAMPLE 1:

#include<iostream>
using namespace std;

int main(){
	int day;
	cout<<" Enter day: ";cin>>day;
	
	(day == 7)? cout<<"adios"<<endl : cout<<"hola"<<endl; 	// COMO UN CONDIFICIONAL SI DAY ES IGUAL A 7 SALE POR CONSOLA "ADIOS" CASO CONTRARIO "HOLA"
	
	return 0;
}

--EQUIVALENTE A HACER :

#include<iostream>
using namespace std;

int main(){
	int day;
	cout<<" Enter day: ";cin>>day;
	
	if(day == 7){
		cout<<" adios"<<endl;
	}
	else{
		cout<<" adios"<<endl;
		
	}
	return 0;
}

-EXAMPLE 2:

int tiempo_de_apertura = (día == FIN_DE_SEMANA) ? 12 : 9;

// TAMBIEN SE PUEDE POR ASIGNACION DONDE SI DIA ES IGUAL A FINSEMANA TIEMPO APERTURA SERA 12 CASO CONTRARIO 9.

--EQUIVALENTE A HACER :

int tiempo_de_apertura;

if (día == FIN_DE_SEMANA)
    tiempo_de_apertura = 12;
else
    tiempo_de_apertura = 9;

--EXAMPLE 3 : RECURSIVIDAD :

#include<iostream>
using namespace std;

int fact(int val){
	return ( val <= 1 )? 1 : val*fact(val-1);
}
int main(){
	cout<<fact(5)<<endl;
	return 0;
}

46 ------------------->>> AUTO REFERENCIA ::

Clase& sumaEntero(int n){     //Retorna el contenido de la direccion de memoria de este clase.
	variableEntera += n;	
	return *this;		// this = puntero , * = indireccion, puntero + indireccion = referencia.
}				//  *this = una variable, no una direccion de memoria.

Clase& sumaFlotante(float n){
	variableFlotante += n;
	return *this;
}


objeto.sumaEntero(5).sumaFlotante(3.5);  //hace el proceso 1 y luego retorna la variable de la clase y llama a otra funcion retornando la variable de clase.

47 ------------------>>> ARBOL C++ : TREE C++ : ARBOLES C++ : TREES C++ :

48 ------------------>>> FRIEND FUNCTION : FUNCTION FRIEND : FUNCION AMIGO : PROTOTIPO DE CLASE : CLASS PROTOTYPE :

>> FUNCION AMIGA: 
- SIRVE PARA PODER ACCEDER A LOS ATRIBUTOS PRIVADOS, PROTEGIDOS Y PUBLICOS DE LA CLASE ENVIADA POR PARAMETROS.
- HAY VECES EN LA CUAL TENDREMOS QUE TOCAR VARIOS ATRIBUTOS PRIVADOS EN VARIAS FUNCIONES Y PARA ENVITAR LA SOBRE CARGA
  DE OPERADORES USAREMOS LAS FUNCIONES AMIGA CON LA PALABRA "friend"; RECORDA QUE LA CLASE AMIGA NO ES UN MIENBRO DE LA CLASE
  ASI QUE SE LLAMA COMO CUALQUIER OTRA FUNCION NORMAL, NO COMO LOS METODOS DE UNA CLASE.

>> PROTOTIPO DE CLASE:
- HAY VECES EN LAS CUALES EL PROGRAMA NO IDENTIFICA EL TIPO DE DATO AGREGADO POR ESO ES RECOMENDABLE USAR EL PROTOTIPO DE CLASE.
  COMO SE USA? PUES SOLO PONEMOS EL TIPO DE DATO "class Carro;" Y SEGUIMOS CON LA FUNCION COMUN "class Empresa{ etc...."
- PARA LLAMAR A LA CLASE USADA POR EL PROTOTIPO USAREMOS HEADER O ARCHIVOS .H, ENCABEZADOS DE CODIGO, SE VERA TODO EN ESTE EJEMPLO.

>> RECORDAR SIEMPRE USAR EL PRAGMA ONCE PARA TODO ARCHIVO ENCABEZADO, HEADER, O .H.
- PARA INTERCONECTAR CLASES U OBJETOS ES IMPORTANTE USAR ESTE TIPO DE ARCHIVO, PORQUE EL PROCESADOR LEERIA EL CODIGO EN FORMA SISTEMATICA NO DE FORMA LINEAL.

////////////////////Archivo: Fecha_header.h ////////////////////////////// 
#pragma once
#include<iostream>

using namespace std;

void entry(char* word,int quan){
	fflush(stdin);
	cin.getline(word,quan,'\n');
	fflush(stdin);
}

class Fecha{
	private:
		int dia,mes,annio;
	public:
		Fecha(int d,int m,int a){
			this->dia = d;
			this->mes = m;
			this->annio = a;
		}
		void show(){
			cout<<dia<<"/"<<mes<<"/"<<annio<<endl;
		}
		~Fecha(){
			cout<<" La fecha fue eliminada."<<endl;
		}
};

////////////////////Archivo: Esposo.h ////////////////////////////// 
#pragma once
#include "Fecha_header.h"
#include "Esposa.h"

class Esposa;

class Esposo{
	friend void change(Esposo *&,Esposa *&);    //PROTOTIPO FUNCION AMIGO
	private:
		char name[30];
		Fecha *fecha_matrimonio;
		Esposa *conyugue;
	public:
		Esposo();
		~Esposo();
		void casarce(Esposa *e,Fecha *f);
		char* get_name();
};

////////////////////Archivo: Esposa.h ////////////////////////////// 
#pragma once
#include "Fecha_header.h"
#include "Esposo.h"

class Esposo;

class Esposa{
	friend void change(Esposo *&,Esposa *&);  //PROTOTIPO FUNCION AMIGO.
	private:
		char name[30];
		Fecha *fecha_matrimonio;
		Esposo *conyugue;
	public:
		Esposa();
		~Esposa();
		void casarce(Esposo *e,Fecha *f);
		char* get_name();
};

////////////////////Archivo: Esposo.cpp ////////////////////////////// 
#include "Esposo.h"

Esposo::Esposo(){
	cout<<" Enter name esposo: ";entry(name,30);
	this->fecha_matrimonio = NULL;
	this->conyugue = NULL;
}
Esposo::~Esposo(){
	delete this->fecha_matrimonio;
	delete this->conyugue;
}
void Esposo::casarce(Esposa *e,Fecha *f){
	this->fecha_matrimonio = f;
	this->conyugue = e;
	cout<<" soy "<<this->name<<" y estoy casado con: "<<this->conyugue->get_name()<<endl;
}

char* Esposo::get_name(){
	return name;
}

////////////////////Archivo: Esposa.cpp ////////////////////////////// 
#include "Esposa.h"


Esposa::Esposa(){
	cout<<" Enter name esposa: ";entry(name,30);
	this->fecha_matrimonio = NULL;
	this->conyugue = NULL;
}
Esposa::~Esposa(){
	delete this->fecha_matrimonio;
	delete this->conyugue;
}
void Esposa::casarce(Esposo *e,Fecha *f){
	this->fecha_matrimonio = f;
	this->conyugue = e;
	cout<<" soy "<<this->name<<" y estoy casado con: "<<this->conyugue->get_name()<<endl;
}

char* Esposa::get_name(){
	return name;
}

////////////////////Archivo: Source.cpp //////////////////////////////
#include<iostream>
#include "Esposa.cpp"
#include "Esposo.cpp"
#include "Fecha_header.h"

#include<string.h>
using namespace std;


void change(Esposo *&e1,Esposa *&e2){       // FUNCION CORRIENDE, FUNCION AMIGO
	char aux[30];
	strcpy(aux,e1->name);          // COMO SE VE SE ESTAN TOCANDO LOS ATRIBUTOS PRIVADOS.
	strcpy(e1->name,e2->name);
	strcpy(e2->name,aux);
	cout<<" Esposo e1 : "<<e1->name<<endl;
	cout<<" Esposa e2: "<<e2->name<<endl;
}

int main(){
	Fecha *fch = new Fecha(19,5,2020);
	Esposa *alexa = new Esposa();
	Esposo *alex= new Esposo();
	
	alexa->casarce(alex,fch);
	alex->casarce(alexa,fch);
	
	change(alex,alexa);   // SE CAMBIARON LOS NOMBRES.
	
	cout<<alexa->get_name()<<endl;       //IMPRIMIRA EL NOMBRE DEL ESPOSO.
	cout<<alex->get_name()<<endl;	   //IMPRIMIRA EL NOMBRE DE LA ESPOSA.
	return 0;
}

49 --------------------->>>> SOBRE CARGA DE OPERADORES :: SOBRECARGA DE OPERADORES :: C++

#include<iostream>
using namespace std;

class Pareja {
public:
    double a, b;

    Pareja(const double a, const double b)    // CONSTRUCTOR NORMAL
    {
        this->a = a;
        this->b = b;
    }
};

 

// Sobrecarga del operador +
Pareja& operator +(const Pareja& p1, const Pareja& p2)     // FUNCION TIPO PAREJA, QUE RESIVE 2 CLASES DE ESTE TIPO Y RETORNA UNA CLASE DEL MISMO TIPO.
{ 							// SE AGREGA EL "OPERATOR" CON CUALQUIER OTRO OPERADOR " +, -, and, or, <<, etc.." PARA INTERPRETARLOS COMO PARAMETROS.
    return *(new Pareja(p1.a + p2.a, p1.b + p2.b));
} 

int main()
{
    Pareja A(50, 75);      // CLASES NOMALMENTE CREADAS.
    Pareja B(150, 175);
    Pareja C = A + B;      // CLASE CON SOBRE CARGA DE CONSTRUCTORES.
 

    cout << "A = " << A.a << ',' << A.b << "\n";     // 50 - 75
    cout << "B = " << B.a << ',' << B.b << "\n";     // 150 - 175
    cout << "C = " << C.a << ',' << C.b << "\n";     // 200 - 250
    
    return 0;
}

EJEMPLO 2:

using namespace std;

class Pareja {

private:
    int a, b;

public:
    // constructor base
    Pareja() : a(0), b(0) {}

    // constructor parametrizado
    Pareja(const int a,const int b) {
	this->a = a;
	this->b = b;
    }

    // constructor de copia
    Pareja(const Pareja&);

    // operadores miembros
    Pareja& operator + (const Pareja &p);
    Pareja& operator - (const Pareja &p);
    Pareja& operator * (const Pareja &p);
    Pareja& operator / (const Pareja &p);
    Pareja& operator = (const Pareja &p);
    Pareja& operator ++();
    bool    operator ==(const Pareja &p) const;

    // operadores no miembros
    friend ostream& operator << (ostream &o,const Pareja &p);
    friend istream& operator >> (istream &o, Pareja &p);
};

// implementacion de los operadores para la clase Pareja
//....................................
Pareja::Pareja(const Pareja &p)
{
    *this=p;
}
//....................................
Pareja& Pareja::operator + (const Pareja &p)
{
    this->a += p.a;
    this->b += p.b;
    return *this;
}
//....................................
Pareja& Pareja::operator - (const Pareja &p)
{
    this->a -= p.a;
    this->b -= p.b;
    return *this;
}
//....................................
Pareja& Pareja::operator * (const Pareja &p)
{
    this->a *= p.a;
    this->b *= p.b;
    return *this;
}
//....................................
Pareja& Pareja::operator / (const Pareja &p)
{
    if (p.a != 0) this->a /= p.a;
    if (p.b != 0) this->b /= p.b;
    return *this;
}
//....................................
Pareja& Pareja::operator = (const Pareja &p)
{
    if(this!=&p){ //Comprueba que no se esté intentanod igualar un objeto a sí mismo
        if (p.a != 0) this->a = p.a;
        if (p.b != 0) this->b = p.b;
    }
    return *this;
}

//....................................
Pareja& Pareja::operator ++ ()
{
    this->a ++;
    this->b ++;
    return *this;
}

//....................................
bool Pareja::operator == (const Pareja &p) const
{
    return this->a == p.a && this->b == p.b;
}

// implemetaci¢n de operadores no miembros
ostream& operator << (ostream &o,const Pareja &p)
{
    o << "(" << p.a << ", " << p.b << ")";
    return o;
}

istream& operator >> (istream &i, Pareja &p)
{
    cout << "Introducir valores para ( a, b) :";
    i >> p.a >> p.b;
    i.ignore();
    return i;
}


// prueba para la clase Pareja
int main()
{
    Pareja A(50,  75);
    Pareja B(100, 15);
    Pareja C;

    cout << "A = " << A << "\n";
    cout << "B = " << B << "\n";
    cout << "........................." << endl;
    C = A * B;
    cout << "A = " << A << "\n";
    cout << "C = " << C << endl;
    cout << "........................." << endl;

    ++C;
    cout << "C = " << C << endl;
    cout << "A == B " << ( (A==B) ? "Si": "No" );
    cin.get();
    return 0;
}

50 --------------------->>> CLASES ABSTRACTAS :: ABSTRACT CLASS :: USE DYNAMIC_CAST<*>() ::

EJEMPLO 1:

#include<iostream>
class Mamifero //clase abstracta(una clase abstracta no puede generar instancias).
{
public:
    Mamifero() :edad(1) { std::cout << "constructor M"; }
    virtual ~Mamifero() { std::cout << "destructor M"; }
    virtual void hablar() const { std::cout << "mamifero talk"; }
protected:
    int edad;
};

 

class Gato : public Mamifero  //clase derivada.
{
public:
    Gato() { std::cout << "constructor G \n"; }
    ~Gato() { std::cout << "Destructor G \n";}
    void hablar() const { std::cout << "miau \n"; }
    void ronronear() const { std::cout << " Rrrr \n"; }
};

 

class Perro : public Mamifero
{
public:
    Perro() { std::cout << "Constructor P \n"; }
    ~Perro() { std::cout << "Destructor P \n"; }
    void hablar() const {std::cout << "\nguau \n";}
};

 

int main()
{
    const int numeroMamifero = 2;
    Mamifero* zoo[numeroMamifero];
    Mamifero* pMamifero;
    int elegir, i;

    for (i = 0; i < numeroMamifero; i++)
    {
        std::cout << "(1)Perro \n(2)gato \n";
        std::cin >> elegir;
        if (elegir == 1)
            pMamifero = new Perro;
        else
            pMamifero = new Gato;
        zoo[i] = pMamifero;
    }
    
    std::cout << "\n";
    
    for (i = 0; i < numeroMamifero; i++)
    {
        zoo[i]->hablar();
        Gato* pRealGato = dynamic_cast<Gato*> (zoo[i]); // si zoo[i] esta declara como clase Gato retorna la memoria de este, caso contrario retorna null o 0.
        if (pRealGato)
            pRealGato->ronronear();
        else
            std::cout<<"no hay gato \n";
        delete zoo[i];
    }

    return 0;
}

51 ------------------>>> for each try : 

#include<iostream>
#include<stdlib.h>
#include<string.h>

using namespace std;

int main(){
	char *arr_c = new char[10];
	cout<< "Enter number: ";cin>>arr_c;
	int length = strlen(arr_c);
	
	int *arr = new int[10];
	
	for(int i=0;i<length;i++){
		arr[i] = (int)arr_c[i] - 48;  // the numbers chars in ASCII begin in 48.
		//arr[i] = arr_c[i]-'0'; // ASCII letter 'num' to num.
	}
	
	for(int i=0;i<length;i++){
		cout<<arr[i]<<endl;
	}

	return 0;
}

52 ------------------>>> vector : use vector : use list :

#include <iostream>
#include <vector>
  
using namespace std;
  
int main()
{
    vector<int> g1;
  
    for (int i = 1; i <= 5; i++)
        g1.push_back(i);
  
    cout << "Size : " << g1.size();
    cout << "\nCapacity : " << g1.capacity();
    cout << "\nMax_Size : " << g1.max_size();
  
    // resizes the vector size to 4
    g1.resize(4);
  
    // prints the vector size after resize()
    cout << "\nSize : " << g1.size();
  
    // checks if the vector is empty or not
    if (g1.empty() == false)
        cout << "\nVector is not empty";
    else
        cout << "\nVector is empty";
  
    // Shrinks the vector
    g1.shrink_to_fit();
    cout << "\nVector elements are: ";
    for (auto it = g1.begin(); it != g1.end(); it++)
        cout << *it << " ";
  
    return 0;
}

OUTPUT

Size : 5
Capacity : 8
Max_Size : 4611686018427387903
Size : 4
Vector is not empty
Vector elements are: 1 2 3 4



// example 2

#include <iostream>
#include <vector>
 
int main()
{
    // Create a vector containing integers
    std::vector<int> v = { 7, 5, 16, 8 };
 
    // Add two more integers to vector
    v.push_back(25);
    v.push_back(13);
 
    // Print out the vector
    std::cout << "v = { ";
    for (int n : v) {
        std::cout << n << ", ";
    }
    std::cout << "}; \n";
}

Output:

v = { 7, 5, 16, 8, 25, 13, };



// example 3:

#include <iostream>
#include <string>
#include <vector>

int main() {
    // Array of string objects
    std::string arr[] = {
        "first",
        "sec",
        "third",
        "fourth"
    };

    // Vector with a string array
    std::vector < std::string > vecOfStr(arr, arr + sizeof(arr) / sizeof(std::string));
    for (std::string str: vecOfStr)
        std::cout << str << std::endl;
}


#include<iostream>
#include<vector>

using namespace std;

int main() {
    vector <int> v {
        1,
        2,
        3,
        4,
        5
    };
    int n = v.size();
    cout << "Size of the vector is :" << n;
}

OUTPUT
5


// list

#include <iostream>
#include <string>
#include <vector>
#include <list>

int main() {
    // std::list of 5 string objects
    std::list < std::string > listOfStr;
    listOfStr.push_back("first");
    listOfStr.push_back("sec");
    listOfStr.push_back("third");
    listOfStr.push_back("fouth");
    // Vector with std::list
    std::vector < std::string > vecOfStr(listOfStr.begin(), listOfStr.end());
    for (std::string str: vecOfStr)
        std::cout << str << std::endl;
}



#include <iostream>
#include <string>
#include <vector>

int main() {
    std::vector < std::string > vecOfStr;
    vecOfStr.push_back("first");
    vecOfStr.push_back("sec");
    vecOfStr.push_back("third");
    // Vector with other string object
    std::vector < std::string > vecOfStr3(vecOfStr);
}



// with struct:

#include <iostream>
#include <vector>

struct BulletPos{
	float h,k,x,y,angle;
};


int main() {
	std::vector<BulletPos> data;
	BulletPos &a = *new BulletPos(), &b = *new BulletPos();
	a.h = 1.2;
	a.k = 2.2;
	a.x = 3.2;
	a.y = 4.2;
	a.angle = 55.2;
	
	data.push_back(a);

	b.h = 10.2;
	b.k = 20.2;
	b.x = 30.2;
	b.y = 40.2;
	b.angle = 550.2;
	
	data.push_back(b);
	
	std::cout<<data.size()<<std::endl;
	data.erase(data.begin());
	std::cout<<data.size()<<std::endl;
	
	for (auto& bp : data){
		printf("(%f, %f)\n",bp.h,bp.k);
	}
	return 0;
}


size() – Returns the number of elements in the vector.
max_size() – Returns the maximum number of elements that the vector can hold.
capacity() – Returns the size of the storage space currently allocated to the vector expressed as number of elements.
resize(n) – Resizes the container so that it contains ‘n’ elements.
empty() – Returns whether the container is empty.
shrink_to_fit() – Reduces the capacity of the container to fit its size and destroys all elements beyond the capacity.
reserve() – Requests that the vector capacity be at least enough to contain n elements.

#include <iostream>
#include <vector>
  
using namespace std;
  
int main()
{
    vector<int> g1;
  
    for (int i = 1; i <= 5; i++)
        g1.push_back(i);
  
    cout << "Size : " << g1.size();
    cout << "\nCapacity : " << g1.capacity();
    cout << "\nMax_Size : " << g1.max_size();
  
    // resizes the vector size to 4
    g1.resize(4);
  
    // prints the vector size after resize()
    cout << "\nSize : " << g1.size();
  
    // checks if the vector is empty or not
    if (g1.empty() == false)
        cout << "\nVector is not empty";
    else
        cout << "\nVector is empty";
  
    // Shrinks the vector
    g1.shrink_to_fit();
    cout << "\nVector elements are: ";
    for (auto it = g1.begin(); it != g1.end(); it++)
        cout << *it << " ";
  
    return 0;
}



// advance :

#include <bits/stdc++.h>
#include <vector>
using namespace std;
  
int main()
{
    // Assign vector
    vector<int> v;
  
    // fill the array with 10 five times
    v.assign(5, 10);
  
    cout << "The vector elements are: ";
    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " ";
  
    // inserts 15 to the last position
    v.push_back(15);
    int n = v.size();
    cout << "\nThe last element is: " << v[n - 1];
  
    // removes last element
    v.pop_back();
  
    // prints the vector
    cout << "\nThe vector elements are: ";
    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " ";
  
    // inserts 5 at the beginning
    v.insert(v.begin(), 5);
  
    cout << "\nThe first element is: " << v[0];
  
    // removes the first element
    v.erase(v.begin());   // type .pop(0)
  
    cout << "\nThe first element is: " << v[0];
  
    // inserts at the beginning
    v.emplace(v.begin(), 5);
    cout << "\nThe first element is: " << v[0];
  
    // Inserts 20 at the end
    v.emplace_back(20);
    n = v.size();
    cout << "\nThe last element is: " << v[n - 1];
  
    // erases the vector
    v.clear();
    cout << "\nVector size after erase(): " << v.size();
  
    // two vector to perform swap
    vector<int> v1, v2;
    v1.push_back(1);
    v1.push_back(2);
    v2.push_back(3);
    v2.push_back(4);
  
    cout << "\n\nVector 1: ";
    for (int i = 0; i < v1.size(); i++)
        cout << v1[i] << " ";
  
    cout << "\nVector 2: ";
    for (int i = 0; i < v2.size(); i++)
        cout << v2[i] << " ";
  
    // Swaps v1 and v2
    v1.swap(v2);
  
    cout << "\nAfter Swap \nVector 1: ";
    for (int i = 0; i < v1.size(); i++)
        cout << v1[i] << " ";
  
    cout << "\nVector 2: ";
    for (int i = 0; i < v2.size(); i++)
        cout << v2[i] << " ";
}

OUTPUT:
The vector elements are: 10 10 10 10 10 
The last element is: 15
The vector elements are: 10 10 10 10 10 
The first element is: 5
The first element is: 10
The first element is: 5
The last element is: 20
Vector size after erase(): 0

Vector 1: 1 2 
Vector 2: 3 4 
After Swap 
Vector 1: 3 4 
Vector 2: 1 2

assign() – It assigns new value to the vector elements by replacing old ones
push_back() – It push the elements into a vector from the back
pop_back() – It is used to pop or remove elements from a vector from the back.
insert() – It inserts new elements before the element at the specified position
erase() – It is used to remove elements from a container from the specified position or range.
swap() – It is used to swap the contents of one vector with another vector of same type. Sizes may differ.
clear() – It is used to remove all the elements of the vector container
emplace() – It extends the container by inserting new element at position
emplace_back() – It is used to insert a new element into the vector container, the new element is added to the end of the vector


// erasing from vector
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector;

  // set some values (from 1 to 10)
  for (int i=1; i<=10; i++) myvector.push_back(i);

  // erase the 6th element
  myvector.erase (myvector.begin()+5);

  // erase the first 3 elements:
  myvector.erase (myvector.begin(),myvector.begin()+3);

  std::cout << "myvector contains:";
  for (unsigned i=0; i<myvector.size(); ++i)
    std::cout << ' ' << myvector[i];
  std::cout << '\n';

  return 0;
}

OUTPUT:
myvector contains: 4 5 7 8 9 10


53 ------------------>>>
54 ------------------>>>
55 ------------------>>>
56 ------------------>>>
57 ------------------>>>
58 ------------------>>>
59 ------------------>>>
60 ------------------>>>
61 ------------------>>>
62 ------------------>>>

------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------" Java "--------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------

system.out.println("hola pendejos del mundo jajaja");
system.out.println("que pedo que pedo");

    int anoNacim = 2001;
    String ciudad = "Arequipa";
    System.out.println("Dia de nacimiento: ");
    System.out.println("no tengo idea");
    System.out.println("month: ");
    System.out.println("febrero");
    System.out.println("por lo que veo naciste en el año "+anoNacim);
    System.out.println("de tal forma que debes tener "+(2019-anoNacim)+ " de edad y naciste en "+ciudad);
    System.out.println("una doctora me puso el nombre T.T");
  }
}

1 -------------------------------------------------------------------------

public class if_condicional {
  public static void main(String[] args) {
    int anoNacim = 1999;
    int edad = 2019-anoNacim;
    System.out.println("");
    if (edad >=18) {
       System.out.println("Eres mayor de edad y puedes tomar conbi");
       System.out.println("");
    }
    else {
       System.out.println("Eres menor de edad y no puedes entrar a los juegos de ni¤os");
       System.out.println("");
    }
   System.out.println("Adios y buenas tardes");
   System.out.println("");
  }
}

2 ----------------------------------------------------------------

public class for_ciclo {
  public static void main(String[] args) {
     int anoNacim = 1975;
     int edad = 2019-anoNacim;
     for(int c=1; c>=edad; c++) {
        System.out.println("");
        System.out.println("ya festeje mi cumplea¤os");
  }
  System.out.println("");
  System.out.println("Entonces tengo "+edad+ " anos de edad");
  }
}

3 ............................ COLA CON ARRAY : ENTRADA : FOR : SWITCH : DO-WHILE : ETC : 

package programa_cola;
import java.util.Scanner;


public class Programa_cola {
    
    public static void main(String[] args) {
        Scanner entrada = new Scanner(System.in);
        int[] cola = new int[30];
        int val;
        cola tail = new cola();
        do{
            System.out.println(" ---------COLA---------\n");
            System.out.println("1)add\n2)show all\n3)advance\n4)exit\n Option: ");
            val = entrada.nextInt();
            switch(val){
                case 1:
                    tail.add_anything();break;
                case 2:
                    tail.show_all();break;
                case 3:
                    tail.advance();break;
                case 4:break;
                default: System.out.println("\nThat option doesnt exist.\n");break;
            }
        }while(val != 4);
    }
}

package programa_cola;     		//CONECCION CON EL PROGRAMA MAIN O CLASE MAIN
import java.util.Scanner;    		//PARA PODER USAR EL INPUT DE CONSOLA

public class cola {					//CLASE COLA
    Scanner entrada = new Scanner(System.in);
    int[] tail = new int[30]; 			//ARRAY
    int pos = 0, val;
    
    public void add_anything(){
       System.out.println(" Enter number: ");
       val = entrada.nextInt();
       tail[pos] = val;
       pos++;
    }
    
    public void show_all(){
        System.out.println("\n SHOW ALL: ");
        for(int i=0; i<pos ;i++){
            System.out.println(" -> " + tail[i]);
        }
    }
    public void advance(){
        for(int i = 0;i<pos;i++){
            tail[i] = tail[i+1];
        }
        pos--;
    }  
}

4 ...................

import java.util.Scanner;

public class Main {
    public static int a,b;
    public static void main(String[] args){
        print_complejos();
        System.out.print(a + " + " + b + "i, " + a + " - " + b + "i, " + a);
    }
    
    public static void print_complejos(){
        a = 3;
        b = 5;
    }
}

import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        print_complejo(5,3);
        print_complejo(5,-3);
        print_complejo(5,0);
        
        
    }
    
    public static void print_complejo(int a, int b){
        if (b == 0){
            System.out.println(a);
        }
        else{
            if (b>0) System.out.println(a + " + " + b + "i");
            else System.out.println(a + " - " + (b*-1) + "i");
        }
    }
}

5 --------------->